<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ°´æ•™å®˜çš„å¤§å†’éšª - æ‰‹æ©Ÿå„ªåŒ–ç‰ˆ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a202c; /* èƒŒæ™¯æ”¹æ·±è‰²ï¼Œè®“éŠæˆ²å€æ›´çªå‡º */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            display: flex;
            flex-direction: column;
            height: 100vh; /* ä½”æ»¿è¦–çª— */
        }

        /* éŠæˆ²ä¸»å€åŸŸå®¹å™¨ */
        #game-container {
            flex: 1; /* ä½”æ“šå‰©é¤˜ç©ºé–“ */
            position: relative;
            overflow: hidden;
            background-color: #f0fdf4; /* éŠæˆ²èƒŒæ™¯è‰² */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            display: block;
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
        }

        /* ç¨ç«‹çš„æ§åˆ¶é¢æ¿å€åŸŸ (åƒ…æ‰‹æ©Ÿé¡¯ç¤º) */
        #controls-panel {
            height: 200px; /* å›ºå®šé«˜åº¦çµ¦æ§åˆ¶å€ */
            background: linear-gradient(to bottom, #1e293b, #0f172a);
            flex-shrink: 0; /* ä¸å…è¨±å£“ç¸® */
            display: none; /* é è¨­éš±è— (é›»è…¦ç‰ˆ) */
            position: relative;
            padding: 10px 20px;
            box-sizing: border-box;
            z-index: 50;
            border-top: 2px solid #334155;
        }

        /* æ‰‹æ©Ÿç‰ˆåª’é«”æŸ¥è©¢ï¼šç•¶è¢å¹•å¯¬åº¦å°æ–¼ 1024px æˆ–æ˜¯ä¸æ”¯æ´æ»‘é¼ æ‡¸åœæ™‚ */
        @media (max-width: 1024px), (hover: none) and (pointer: coarse) {
            #controls-panel { display: flex; justify-content: space-between; align-items: center; }
            /* èª¿æ•´ä¸Šæ–¹ UI å­—é«” */
            .hud-text { font-size: 0.9rem; }
        }

        /* HUD (æŠ¬é ­é¡¯ç¤ºå™¨) - ä¾ç„¶è¦†è“‹åœ¨éŠæˆ²å€ä¸Šæ–¹ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%; /* è·Ÿéš¨ game-container çš„é«˜åº¦ */
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 10;
        }
        .hud-text {
            color: #1e293b;
            text-shadow: 2px 2px 0 #fff;
            pointer-events: none;
            font-weight: 800;
        }

        /* --- æ§åˆ¶å…ƒä»¶æ¨£å¼ (ç¾åœ¨ä½æ–¼ controls-panel å…§) --- */

        /* è™›æ“¬æ–æ¡¿ D-Pad */
        .d-pad {
            position: relative;
            width: 140px;
            height: 140px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .d-btn {
            position: absolute;
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            width: 45px;
            height: 45px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            font-size: 24px;
            transition: transform 0.1s, background 0.1s;
        }
        .d-btn:active { background: rgba(255, 255, 255, 0.4); transform: scale(0.9); }

        .d-up { top: 5px; left: 47.5px; }
        .d-down { bottom: 5px; left: 47.5px; }
        .d-left { top: 47.5px; left: 5px; }
        .d-right { top: 47.5px; right: 5px; }

        /* ä¸­å¤®å€åŸŸ (æ­¦å™¨æ¬„) */
        .center-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
        }

        .weapon-bar {
            display: flex;
            gap: 15px;
            background: rgba(0,0,0,0.3);
            padding: 8px 16px;
            border-radius: 24px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .weapon-slot {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            border: 2px solid #475569;
            background: #1e293b;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
        }

        .weapon-slot.active {
            border-color: #3b82f6;
            background-color: #3b82f6; /* æ¿€æ´»æ™‚äº®è‰² */
            transform: translateY(-5px);
            box-shadow: 0 0 10px #3b82f6;
        }

        .weapon-slot.disabled {
            opacity: 0.4;
            filter: grayscale(100%);
        }

        .weapon-slot .badge {
            position: absolute;
            top: -8px;
            right: -8px;
            background: #ef4444;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 11px;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid white;
        }

        /* å³å´å‹•ä½œæŒ‰éˆ• */
        .action-group {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .action-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            position: relative;
            transition: transform 0.1s;
            border: 3px solid rgba(255,255,255,0.3);
        }
        .action-btn:active { transform: scale(0.9); filter: brightness(1.1); }

        #btn-shoot { background: #3b82f6; }
        #btn-build { background: #10b981; }
        #btn-mine { background: #ef4444; }

        .flash-msg {
            color: #a855f7;
            font-weight: bold;
            font-size: 12px;
            margin-bottom: 8px;
            text-align: center;
            background: rgba(0,0,0,0.6);
            padding: 2px 8px;
            border-radius: 4px;
            color: #e9d5ff;
            animation: blink 1s infinite;
            display: none;
        }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

        /* æ¨¡æ…‹è¦–çª— */
        .modal-overlay {
            display: none;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 100; /* æœ€ä¸Šå±¤ */
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            backdrop-filter: blur(4px);
        }
        .modal-box {
            background: white;
            padding: 2rem;
            border-radius: 1.5rem;
            text-align: center;
            max-width: 85%;
            width: 400px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.2);
            border: 4px solid #3b82f6;
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .rule-list { text-align: left; margin: 15px 0; font-size: 14px; color: #374151; line-height: 1.5; max-height: 50vh; overflow-y: auto; }
        .rule-list li { margin-bottom: 8px; padding-left: 24px; position: relative; }
        .rule-list li::before { content: "âœ¨"; position: absolute; left: 0; top: 0; font-size: 14px; }
        @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        .btn-green { background: #22c55e; color: white; padding: 12px 30px; border-radius: 12px; font-weight: bold; margin: 5px; border-bottom: 4px solid #15803d; transition: all 0.1s; font-size: 18px; width: 100%; }
        .btn-green:active { border-bottom: 0; transform: translateY(4px); }

    </style>
</head>
<body>

    <!-- éŠæˆ²ç•«é¢å€ (ä¸Šæ–¹) -->
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>

        <!-- HUD (åƒ…é¡¯ç¤ºè³‡è¨Šï¼Œä¸åŒ…å«æ§åˆ¶) -->
        <div id="ui-layer">
            <div class="p-4 flex justify-between items-start w-full">
                <div>
                    <h1 class="text-2xl font-black hud-text text-blue-700 tracking-wider drop-shadow-lg">æ°´æ•™å®˜çš„å¤§å†’éšª</h1>
                    <div class="mt-1 flex items-center gap-3">
                        <div class="text-red-500 font-bold hud-text text-lg" id="hp-display">HP: â¤ï¸â¤ï¸â¤ï¸</div>
                        <div class="text-yellow-500 font-bold hud-text text-lg flex items-center gap-1 bg-white/50 px-2 rounded-full">
                            ğŸ’° <span id="coin-display">0</span>
                        </div>
                    </div>
                </div>
                <div class="text-right">
                    <div class="text-lg font-bold text-red-600 hud-text bg-white/50 px-2 rounded" id="enemy-count">å‰©é¤˜æ•µäºº: 0</div>
                    <div class="text-sm font-bold text-gray-500 hud-text mt-1" id="time-display">00:00</div>

                    <div id="desktop-hints" class="hidden mt-2 flex flex-col items-end gap-2 lg:flex">
                        <div class="bg-green-600 text-white text-xs px-2 py-1 rounded shadow">
                            æŒ‰ B å»ºé€ å¯¦é«”æ°´ç®¡ (å…è²»)
                        </div>
                        <div class="bg-blue-600 text-white text-xs px-2 py-1 rounded shadow">
                            æŒ‰ ç©ºç™½éµ å°„æ“Š
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ç¨ç«‹æ§åˆ¶é¢æ¿å€ (ä¸‹æ–¹ï¼Œåƒ…æ‰‹æ©Ÿé¡¯ç¤º) -->
    <div id="controls-panel">
        <!-- å·¦å´æ–æ¡¿ -->
        <div class="d-pad">
            <div class="d-btn d-up" id="btn-up">â–²</div>
            <div class="d-btn d-left" id="btn-left">â—€</div>
            <div class="d-btn d-right" id="btn-right">â–¶</div>
            <div class="d-btn d-down" id="btn-down">â–¼</div>
        </div>

        <!-- ä¸­å¤®æ­¦å™¨æ¬„ -->
        <div class="center-controls">
            <div id="mine-hint" class="flash-msg">ç²å¾—åœ°é›·ï¼é»æ“Šåˆ‡æ›</div>
            <div class="weapon-bar">
                <div class="weapon-slot active" id="slot-water" onclick="switchWeapon('normal')">
                    ğŸ’¦
                </div>
                <div class="weapon-slot" id="slot-mine" onclick="switchWeapon('super')">
                    ğŸ’£
                    <div class="badge" id="mine-badge">0</div>
                </div>
            </div>
        </div>

        <!-- å³å´å‹•ä½œæŒ‰éˆ• -->
        <div class="action-group">
            <!-- å»ºé€ /åœ°é›· (BéµåŠŸèƒ½) -->
            <div class="action-btn" id="btn-mine" onmousedown="player.placeMine()" ontouchstart="player.placeMine()">ğŸ’£</div>
            <!-- å°„æ“Š (ç©ºç™½éµåŠŸèƒ½) -->
            <div class="action-btn" id="btn-shoot" onmousedown="player.shoot()" ontouchstart="player.shoot()">ğŸ”¥</div>
        </div>
    </div>

    <!-- éŠæˆ²è¦å‰‡è¦–çª— -->
    <div id="start-modal" class="modal-overlay" style="display: flex;">
        <div class="modal-box">
            <h2 class="text-3xl font-black mb-2 text-blue-600">ä»»å‹™ç°¡å ±</h2>
            <div class="rule-list">
                <ul>
                    <li><strong>ä»»å‹™ç›®æ¨™ï¼š</strong> æ¸…é™¤å ´ä¸Šæ‰€æœ‰<span class="text-red-500 font-bold">ç´°èŒ</span>èˆ‡<span class="text-yellow-700 font-bold">é«’æ°´ç®¡</span>ã€‚</li>
                    <li><strong>ä»‹é¢æ“ä½œï¼š</strong>
                        <br>ä¸Šæ–¹æ˜¯éŠæˆ²ç•«é¢ï¼Œä¸‹æ–¹æ˜¯æ§åˆ¶å€ã€‚ä¸æœƒå†æ“‹ä½è¦–ç·šäº†ï¼
                        <br>å·¦ä¸‹æ§åˆ¶ç§»å‹•ï¼Œå³ä¸‹æ§åˆ¶æ”»æ“Šèˆ‡åœ°é›·ã€‚
                    </li>
                    <li><strong>ç²¾æº–å°„æ“Šï¼š</strong> å¿…é ˆå°æº–<span class="text-yellow-500 font-bold">é‡‘è‰²ç®¡å£</span>å°„æ“Šæ‰æœ‰æ•ˆï¼</li>
                    <li><strong>è¶…ç´šæ­¦å™¨ï¼š</strong> é›†æ»¿ 5 é‡‘å¹£è‡ªå‹•ç²å¾—<span class="text-red-500 font-bold">åå­—åœ°é›·</span>ï¼Œè¨˜å¾—åœ¨ä¸‹æ–¹åˆ‡æ›ä½¿ç”¨ã€‚</li>
                </ul>
            </div>
            <button onclick="startGame()" class="btn-green">
                é–‹å§‹è¡Œå‹•
            </button>
        </div>
    </div>

    <!-- çµç®—è¦–çª— -->
    <div id="game-over-modal" class="modal-overlay">
        <div class="modal-box">
            <h2 class="text-4xl font-black mb-2 text-gray-800" id="modal-title">GAME OVER</h2>
            <p class="text-gray-600 mb-6 font-bold text-lg" id="modal-message">...</p>
            <button onclick="restartGame()" class="btn-green">
                å†ä¾†ä¸€æ¬¡
            </button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');

        // --- éŠæˆ²å¸¸æ•¸ ---
        const TILE_SIZE = 64;
        const PLAYER_SIZE = 48;
        const COLORS = {
            bg: '#f0fdf4',
            grid: '#dcfce7',
            pipeMetal: '#94a3b8',
            pipeDirty: '#854d0e',
            woodDark: '#713f12',
            woodLight: '#a16207',
            water: '#60a5fa',
            blocked: '#64748b',
            bacteria: '#16a34a',
            gold: '#fbbf24',
            skin: '#fcd34d',
            shirt: '#16a34a',
            pants: '#1e3a8a',
            glasses: '#000000',
            stench: '#a3e635',
            dust: '#57534e',
            mine: '#1f2937',
            explosion: '#ef4444'
        };

        // --- éŠæˆ²ç‹€æ…‹ ---
        let gameState = {
            running: false,
            time: 0,
            lastFrameTime: 0,
            coins: 0,
            mineCount: 0,
            bacteriaCount: 0,
            maxBacteria: 10,
            pipesSpawned: 0,
            maxPipes: 20,
            currentWeapon: 'normal'
        };

        let keys = {};

        let player;
        let obstacles = [];
        let enemies = [];
        let projectiles = [];
        let particles = [];
        let mines = [];
        let explosions = [];

        let mapGrid = [];
        let mapRows = 0;
        let mapCols = 0;

        let uiElements = {
            hp: document.getElementById('hp-display'),
            coins: document.getElementById('coin-display'),
            enemyCount: document.getElementById('enemy-count'),
            time: document.getElementById('time-display'),
            modalOver: document.getElementById('game-over-modal'),
            modalStart: document.getElementById('start-modal'),
            title: document.getElementById('modal-title'),
            msg: document.getElementById('modal-message'),
            mineBadge: document.getElementById('mine-badge'),
            mineHint: document.getElementById('mine-hint'),
            slotNormal: document.getElementById('slot-water'),
            slotSuper: document.getElementById('slot-mine')
        };

        function checkCollision(rect1, rect2) {
            return (rect1.x < rect2.x + rect2.w &&
                    rect1.x + rect1.w > rect2.x &&
                    rect1.y < rect2.y + rect2.h &&
                    rect1.y + rect1.h > rect2.y);
        }

        class Particle {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type; this.life = 1.0;
                let angle = Math.random() * Math.PI * 2;
                let speed = Math.random() * 2 + 1;

                if (type === 'coin') {
                    this.vx = 0; this.vy = -1; this.decay = 0.02; this.size = 8; this.color = COLORS.gold;
                } else if (type === 'smoke') {
                    this.vx = Math.cos(angle) * speed * 0.5; this.vy = Math.sin(angle) * speed * 0.5 - 1;
                    this.decay = 0.04; this.size = Math.random() * 8 + 4; this.color = '#fff';
                } else if (type === 'kill') {
                    this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed;
                    this.decay = 0.05; this.size = Math.random() * 6 + 3; this.color = COLORS.bacteria;
                } else if (type === 'explosion') {
                    this.vx = Math.cos(angle) * speed * 2; this.vy = Math.sin(angle) * speed * 2;
                    this.decay = 0.05; this.size = Math.random() * 8 + 4; this.color = '#fca5a5';
                } else if (type === 'stench') {
                    this.vx = Math.cos(angle) * 0.5; this.vy = -1 - Math.random();
                    this.decay = 0.02; this.size = Math.random() * 6 + 2; this.color = COLORS.stench;
                } else if (type === 'dust') {
                    this.vx = Math.cos(angle) * speed * 0.5; this.vy = Math.sin(angle) * speed * 0.5;
                    this.decay = 0.03; this.size = Math.random() * 3 + 1; this.color = COLORS.dust;
                } else {
                    this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed;
                    this.decay = 0.05; this.size = Math.random() * 4 + 2;
                    this.color = type === 'water' ? '#bae6fd' : COLORS.pipeDirty;
                }
            }
            update() { this.x += this.vx; this.y += this.vy; this.life -= this.decay; }
            draw(ctx) {
                ctx.save(); ctx.globalAlpha = this.life; ctx.fillStyle = this.color;
                if (this.type === 'coin') { ctx.font = "20px Arial"; ctx.fillText("ğŸ’°", this.x, this.y); }
                else { ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); }
                ctx.restore();
            }
        }

        class Mine {
            constructor(c, r) {
                this.c = c; this.r = r;
                this.x = c * TILE_SIZE + TILE_SIZE/2;
                this.y = r * TILE_SIZE + TILE_SIZE/2;
                this.timer = 180;
                this.exploded = false;
            }
            update() {
                if (this.exploded) return;
                this.timer--;
                if (this.timer <= 0) {
                    this.explode();
                }
            }
            explode() {
                this.exploded = true;
                explosions.push(new Explosion(this.c, this.r));
            }
            draw(ctx) {
                if (this.exploded) return;
                let scale = 1.0 + Math.sin(Date.now() / 100) * 0.1;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(scale, scale);

                ctx.fillStyle = COLORS.mine;
                ctx.beginPath(); ctx.arc(0, 5, 15, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = '#d1d5db'; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(5, -20); ctx.stroke();
                if (Math.random() > 0.5) {
                    ctx.fillStyle = '#ef4444';
                    ctx.beginPath(); ctx.arc(5, -20, 3, 0, Math.PI*2); ctx.fill();
                }

                ctx.fillStyle = 'white'; ctx.font = "bold 12px Arial"; ctx.textAlign = "center";
                ctx.fillText(Math.ceil(this.timer/60), 0, 8);
                ctx.restore();
            }
        }

        class Explosion {
            constructor(centerC, centerR) {
                this.centerC = centerC; this.centerR = centerR;
                this.life = 30;
                this.rects = [];
                this.rects.push({x: 0, y: centerR * TILE_SIZE, w: canvas.width, h: TILE_SIZE});
                this.rects.push({x: centerC * TILE_SIZE, y: 0, w: TILE_SIZE, h: canvas.height});
                this.checkDamage();
            }
            update() { this.life--; }
            checkDamage() {
                enemies.forEach(bug => { if (this.checkHit(bug)) bug.die(); });
                obstacles.forEach(obs => {
                    if (obs.type === 'pipe' && !obs.markedForDeletion && this.checkHit(obs)) {
                        obs.destroyByMine();
                    }
                });
            }
            checkHit(entity) {
                for (let r of this.rects) { if (checkCollision(r, entity)) return true; }
                return false;
            }
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.life / 30;
                ctx.fillStyle = COLORS.explosion;
                let cx = this.centerC * TILE_SIZE + TILE_SIZE/2;
                let cy = this.centerR * TILE_SIZE + TILE_SIZE/2;
                ctx.fillRect(0, cy - 20, canvas.width, 40);
                ctx.fillRect(cx - 20, 0, 40, canvas.height);
                ctx.beginPath(); ctx.arc(cx, cy, 40, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            }
        }

        class Obstacle {
            constructor(c, r, type, orientation = 'horizontal') {
                this.c = c; this.r = r;
                this.x = c * TILE_SIZE; this.y = r * TILE_SIZE;
                this.w = TILE_SIZE; this.h = TILE_SIZE;
                this.type = type;
                this.orientation = orientation;
                this.dirtLevel = 100;
                this.markedForDeletion = false;

                this.openings = [];
                if (this.type === 'pipe') {
                    this.visualX = this.x; this.visualY = this.y;
                    this.visualW = this.w; this.visualH = this.h;
                    const openingDepth = 8; const openingWidth = 32;

                    if (this.orientation === 'horizontal') {
                        this.visualY += 12; this.visualH -= 24;
                        this.openings.push({x: this.x, y: this.y + this.h/2 - openingWidth/2, w: openingDepth, h: openingWidth, dir: 'left'});
                        this.openings.push({x: this.x + this.w - openingDepth, y: this.y + this.h/2 - openingWidth/2, w: openingDepth, h: openingWidth, dir: 'right'});
                    } else {
                        this.visualX += 12; this.visualW -= 24;
                        this.openings.push({x: this.x + this.w/2 - openingWidth/2, y: this.y, w: openingWidth, h: openingDepth, dir: 'up'});
                        this.openings.push({x: this.x + this.w/2 - openingWidth/2, y: this.y + this.h - openingDepth, w: openingWidth, h: openingDepth, dir: 'down'});
                    }
                }
            }

            update() {
                if (this.type === 'pipe' && this.dirtLevel > 0) {
                    if (Math.random() < 0.02) {
                        let px = this.x + Math.random() * this.w; let py = this.y + Math.random() * this.h;
                        particles.push(new Particle(px, py, 'stench'));
                    }
                    if (Math.random() < 0.01) {
                        let px = this.x + Math.random() * this.w; let py = this.y + Math.random() * this.h;
                        particles.push(new Particle(px, py, 'dust'));
                    }
                }
            }

            checkHit(projectile) {
                if (this.type === 'fence') return 'blocked';
                if (!checkCollision(projectile, this)) return false;

                for (let op of this.openings) {
                    if (checkCollision(projectile, op)) {
                        let correctDir = false;
                        if (op.dir === 'left' && projectile.vx > 0) correctDir = true;
                        if (op.dir === 'right' && projectile.vx < 0) correctDir = true;
                        if (op.dir === 'up' && projectile.vy > 0) correctDir = true;
                        if (op.dir === 'down' && projectile.vy < 0) correctDir = true;
                        if (correctDir) {
                            this.clean(34);
                            return 'cleaned';
                        }
                    }
                }
                return 'blocked';
            }

            clean(amount) {
                if (this.markedForDeletion) return;
                this.dirtLevel = Math.max(0, this.dirtLevel - amount);
                for(let i=0; i<3; i++) {
                     let px = this.x + TILE_SIZE/2; let py = this.y + TILE_SIZE/2;
                     particles.push(new Particle(px, py, 'dirt'));
                }
                if (this.dirtLevel <= 0) {
                    this.destroyByMine();
                }
            }

            destroyByMine() {
                if (this.markedForDeletion) return;
                this.markedForDeletion = true;
                particles.push(new Particle(this.x + this.w/2, this.y, 'coin'));
                gameState.coins++;
                checkAutoBuy();
                updateUI();
                for(let i=0; i<8; i++) {
                    let px = this.x + Math.random()*this.w; let py = this.y + Math.random()*this.h;
                    particles.push(new Particle(px, py, 'smoke'));
                }
                checkWin();
            }

            draw(ctx) {
                if (this.type === 'fence') {
                    ctx.fillStyle = COLORS.woodDark;
                    ctx.fillRect(this.x + 10, this.y + 5, 10, this.h - 10);
                    ctx.fillRect(this.x + this.w - 20, this.y + 5, 10, this.h - 10);
                    ctx.fillStyle = COLORS.woodLight;
                    ctx.fillRect(this.x + 5, this.y + 15, this.w - 10, 12);
                    ctx.fillRect(this.x + 5, this.y + this.h - 25, this.w - 10, 12);
                } else {
                    ctx.fillStyle = '#475569';
                    ctx.fillRect(this.visualX, this.visualY, this.visualW, this.visualH);
                    ctx.fillStyle = COLORS.pipeMetal;
                    ctx.fillRect(this.visualX+4, this.visualY+4, this.visualW-8, this.visualH-8);
                    if (this.dirtLevel > 0) {
                        let alpha = this.dirtLevel / 100;
                        ctx.fillStyle = `rgba(133, 77, 14, ${alpha})`;
                        ctx.fillRect(this.visualX+4, this.visualY+4, this.visualW-8, this.visualH-8);
                    }
                    ctx.fillStyle = COLORS.gold;
                    this.openings.forEach(op => {
                        ctx.fillRect(op.x, op.y, op.w, op.h);
                        ctx.strokeStyle = '#b45309'; ctx.lineWidth = 2;
                        ctx.strokeRect(op.x, op.y, op.w, op.h);
                    });
                }
            }
        }

        class Bacteria {
            constructor(c, r) {
                this.w = 40; this.h = 40;
                this.x = c * TILE_SIZE + (TILE_SIZE - this.w)/2;
                this.y = r * TILE_SIZE + (TILE_SIZE - this.h)/2;
                this.speed = 2.5; this.vx = 0; this.vy = 0; this.active = true;
                this.chooseDirection(c, r);
            }
            update() {
                if (!this.active) return;
                let cx = this.x + this.w/2; let cy = this.y + this.h/2;
                let cellX = Math.floor(cx / TILE_SIZE); let cellY = Math.floor(cy / TILE_SIZE);
                let centerX = cellX * TILE_SIZE + TILE_SIZE/2; let centerY = cellY * TILE_SIZE + TILE_SIZE/2;

                if (Math.abs(cx - centerX) < 4 && Math.abs(cy - centerY) < 4) {
                    if (Math.random() < 0.3 || this.isBlocked(cellX, cellY, Math.sign(this.vx), Math.sign(this.vy))) {
                        this.x = centerX - this.w/2; this.y = centerY - this.h/2;
                        this.chooseDirection(cellX, cellY);
                    }
                }
                this.x += this.vx; this.y += this.vy;
            }
            isBlocked(c, r, dx, dy) {
                let nextC = c + dx; let nextR = r + dy;
                if (nextC < 0 || nextC >= mapCols || nextR < 0 || nextR >= mapRows) return true;
                if (mapGrid[nextR][nextC] === 1) return true;
                return false;
            }
            chooseDirection(currC, currR) {
                let dirs = [{x:1, y:0}, {x:-1, y:0}, {x:0, y:1}, {x:0, y:-1}];
                dirs.sort(() => Math.random() - 0.5);
                for (let d of dirs) {
                    if (!this.isBlocked(currC, currR, d.x, d.y)) {
                        this.vx = d.x * this.speed; this.vy = d.y * this.speed; return;
                    }
                }
                this.vx = 0; this.vy = 0;
            }
            die() {
                if (!this.active) return;
                this.active = false;
                for(let i=0; i<6; i++) {
                    let px = this.x + Math.random()*this.w; let py = this.y + Math.random()*this.h;
                    particles.push(new Particle(px, py, 'kill'));
                }
                checkWin();
            }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x + this.w/2, this.y + this.h/2);
                ctx.fillStyle = COLORS.bacteria;
                ctx.beginPath(); ctx.arc(0, -5, 15, Math.PI, 0); ctx.lineTo(15, 15); ctx.lineTo(-15, 15); ctx.closePath(); ctx.fill();
                let walkOffset = Math.sin(Date.now() / 80) * 3;
                ctx.fillRect(-10, 15, 6, 6 + walkOffset); ctx.fillRect(4, 15, 6, 6 - walkOffset);
                ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(-5, -5, 5, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(5, -5, 5, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(-5, -5, 2, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(5, -5, 2, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = 'black'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(-10, -10); ctx.lineTo(-2, -6); ctx.stroke(); ctx.beginPath(); ctx.moveTo(10, -10); ctx.lineTo(2, -6); ctx.stroke();
                ctx.restore();
            }
        }

        class Player {
            constructor() {
                this.w = PLAYER_SIZE; this.h = 60;
                this.x = TILE_SIZE * 1.5 - this.w/2; this.y = TILE_SIZE * 1.5 - this.h/2;
                this.speed = 4; this.hp = 3; this.invincibleTimer = 0; this.facing = {x: 0, y: 1}; this.shootCooldown = 0;
            }
            update() {
                if (this.invincibleTimer > 0) this.invincibleTimer--;
                let dx = 0; let dy = 0;
                if (keys['w'] || keys['ArrowUp']) dy = -1; if (keys['s'] || keys['ArrowDown']) dy = 1;
                if (keys['a'] || keys['ArrowLeft']) dx = -1; if (keys['d'] || keys['ArrowRight']) dx = 1;

                if (dx !== 0 || dy !== 0) {
                    this.facing = {x: dx || 0, y: dy || 0};
                    if (dx !== 0) {
                        let nextX = this.x + dx * this.speed;
                        if (!this.checkWallCollision(nextX, this.y)) this.x = nextX;
                        else {
                             let gridY = Math.round(this.y / TILE_SIZE) * TILE_SIZE + (TILE_SIZE - this.h)/2;
                             if (Math.abs(gridY - this.y) < 20) this.y += Math.sign(gridY - this.y) * this.speed;
                        }
                    }
                    if (dy !== 0) {
                        let nextY = this.y + dy * this.speed;
                        if (!this.checkWallCollision(this.x, nextY)) this.y = nextY;
                        else {
                            let gridX = Math.round(this.x / TILE_SIZE) * TILE_SIZE + (TILE_SIZE - this.w)/2;
                            if (Math.abs(gridX - this.x) < 20) this.x += Math.sign(gridX - this.x) * this.speed;
                        }
                    }
                }
                if (this.shootCooldown > 0) this.shootCooldown--;
                if (keys[' '] && this.shootCooldown <= 0) this.shoot();

                if (this.invincibleTimer <= 0) {
                    let hitRect = {x: this.x+8, y: this.y+8, w: this.w-16, h: this.h-16};
                    for (let bug of enemies) {
                        if (checkCollision(hitRect, bug)) { this.takeDamage(bug); break; }
                    }
                }
            }
            shoot() {
                let shootDir = {x:0, y:0};
                if (Math.abs(this.facing.x) > Math.abs(this.facing.y)) shootDir.x = Math.sign(this.facing.x);
                else shootDir.y = Math.sign(this.facing.y) || 1;

                projectiles.push(new WaterProjectile(this.x + this.w/2, this.y + this.h/2, shootDir.x, shootDir.y));
                this.shootCooldown = 15;
            }
            placeMine() {
                if (gameState.mineCount > 0) {
                    let c = Math.floor((this.x + this.w/2) / TILE_SIZE);
                    let r = Math.floor((this.y + this.h/2) / TILE_SIZE);
                    if (mapGrid[r][c] === 0) {
                        mines.push(new Mine(c, r));
                        gameState.mineCount--;
                        updateUI();
                    }
                }
            }
            checkWallCollision(x, y) {
                let testRect = {x: x, y: y, w: this.w, h: this.h};
                for (let obs of obstacles) {
                    if (checkCollision(testRect, obs)) return true;
                }
                if (x < 0 || x + this.w > canvas.width || y < 0 || y + this.h > canvas.height) return true;
                return false;
            }
            takeDamage(sourceBug) {
                this.hp--; this.invincibleTimer = 120; updateUI();
                ctx.fillStyle = 'rgba(255,50,50,0.5)'; ctx.fillRect(0,0,canvas.width,canvas.height);
                if (sourceBug) {
                    let centerX = this.x + this.w/2; let centerY = this.y + this.h/2;
                    let bugX = sourceBug.x + sourceBug.w/2; let bugY = sourceBug.y + sourceBug.h/2;
                    let dx = centerX - bugX; let dy = centerY - bugY;
                    let dist = Math.sqrt(dx*dx + dy*dy); if (dist === 0) { dx = 1; dist = 1; }
                    let targetX = this.x + (dx/dist) * 60; let targetY = this.y + (dy/dist) * 60;
                    if (!this.checkWallCollision(targetX, targetY)) { this.x = targetX; this.y = targetY; }
                }
                if (this.hp <= 0) endGame(false);
            }
            draw(ctx) {
                if (this.invincibleTimer > 0 && Math.floor(Date.now() / 100) % 2 === 0) return;
                const cx = this.x + this.w/2; const cy = this.y + this.h/2;
                ctx.save(); ctx.translate(cx, cy);

                let dir = 1;
                if (this.facing.x < 0) dir = -1;
                ctx.scale(dir, 1);

                let w = 40; let h = 60;

                ctx.fillStyle = COLORS.pants; ctx.fillRect(-10, 10, 20, 20);
                let walkOffset = Math.sin(Date.now() / 100) * 4;
                if (this.facing.x === 0 && this.facing.y === 0) walkOffset = 0;
                ctx.fillStyle = '#3e2723'; ctx.fillRect(-10, 28 + walkOffset, 8, 6); ctx.fillRect(2, 28 - walkOffset, 8, 6);

                ctx.fillStyle = COLORS.shirt; ctx.fillRect(-12, -15, 24, 25);
                ctx.fillRect(-16, -15, 4, 18); ctx.fillRect(12, -15, 4, 18);
                ctx.fillStyle = COLORS.skin; ctx.fillRect(-16, 3, 4, 5); ctx.fillRect(12, 3, 4, 5);

                ctx.fillStyle = COLORS.skin; ctx.fillRect(-10, -35, 20, 22);
                ctx.fillStyle = '#3e2723'; ctx.fillRect(-10, -38, 20, 6); ctx.fillRect(-12, -35, 2, 10);

                ctx.strokeStyle = COLORS.glasses; ctx.lineWidth = 2;
                ctx.strokeRect(-8, -28, 6, 4); ctx.strokeRect(2, -28, 6, 4);
                ctx.beginPath(); ctx.moveTo(-2, -26); ctx.lineTo(2, -26); ctx.stroke();

                ctx.fillStyle = 'black'; ctx.fillRect(-6, -27, 2, 2); ctx.fillRect(4, -27, 2, 2);
                ctx.beginPath(); ctx.moveTo(-4, -18); ctx.quadraticCurveTo(0, -15, 4, -18); ctx.stroke();

                ctx.restore();
            }
        }

        class WaterProjectile {
            constructor(x, y, dx, dy) {
                this.x = x; this.y = y;
                this.w = 6; this.h = 6;
                this.vx = dx * 8; this.vy = dy * 8;
                this.active = true;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) this.active = false;
                if (!this.active) return;

                let c = Math.floor(this.x / TILE_SIZE); let r = Math.floor(this.y / TILE_SIZE);
                let hitPipe = obstacles.find(p => p.c === c && p.r === r);
                if (hitPipe) {
                    let result = hitPipe.checkHit(this);
                    if (result === 'cleaned') {
                        this.active = false;
                        for(let i=0; i<4; i++) particles.push(new Particle(this.x, this.y, 'water'));
                    } else if (result === 'blocked') {
                        this.active = false;
                        for(let i=0; i<3; i++) particles.push(new Particle(this.x, this.y, 'blocked'));
                    }
                }
                for (let bug of enemies) {
                    if (checkCollision(this, bug)) {
                        this.active = false;
                        bug.x += this.vx * 0.5; bug.y += this.vy * 0.5; // æ“Šé€€
                        for(let i=0; i<3; i++) particles.push(new Particle(this.x, this.y, 'water'));
                        return;
                    }
                }
            }
            draw(ctx) {
                ctx.fillStyle = COLORS.water;
                ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = 'white'; ctx.lineWidth = 1; ctx.stroke();
            }
        }

        // --- æ ¸å¿ƒé‚è¼¯ ---
        function resizeCanvas() {
            // ç²å–éŠæˆ²å®¹å™¨çš„å°ºå¯¸ (è€Œä¸æ˜¯è¦–çª—)
            const container = document.getElementById('game-container');
            if(container) {
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;

                // æ›´æ–°åœ°åœ–è¡Œåˆ—æ•¸
                mapCols = Math.floor(canvas.width / TILE_SIZE);
                mapRows = Math.floor(canvas.height / TILE_SIZE);
                if (mapCols % 2 === 0) mapCols--; if (mapRows % 2 === 0) mapRows--;
            }
        }

        function initGame() {
            resizeCanvas();

            obstacles = []; enemies = []; projectiles = []; particles = []; mines = []; explosions = [];
            gameState.time = 0; gameState.coins = 0; gameState.mineCount = 0;
            gameState.running = false;
            gameState.bacteriaCount = 0; gameState.pipesSpawned = 0;

            generateLevel(mapCols, mapRows);
            player = new Player();
            updateUI();

            uiElements.modalStart.style.display = 'flex';
            uiElements.modalOver.style.display = 'none';
            uiElements.mineHint.style.display = 'none';
        }

        function startGame() {
            uiElements.modalStart.style.display = 'none';
            gameState.running = true;
            gameState.lastFrameTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        function generateLevel(cols, rows) {
            mapGrid = Array(rows).fill().map(() => Array(cols).fill(0));
            obstacles = [];
            for (let c = 0; c < cols; c++) { addObstacle(c, 0, 'fence'); addObstacle(c, rows-1, 'fence'); }
            for (let r = 1; r < rows-1; r++) { addObstacle(0, r, 'fence'); addObstacle(cols-1, r, 'fence'); }
            let safeZone = {r: 4, c: 4};
            for (let r = 2; r < rows - 2; r += 2) {
                for (let c = 2; c < cols - 2; c += 2) {
                    if (r < safeZone.r && c < safeZone.c) continue;
                    let rand = Math.random();
                    if (rand < 0.4) addObstacle(c, r, 'pipe', Math.random()>0.5?'horizontal':'vertical');
                }
            }
        }

        function addObstacle(c, r, type, orientation = 'horizontal') {
            mapGrid[r][c] = 1;
            obstacles.push(new Obstacle(c, r, type, orientation));
        }

        function switchWeapon(type) {
            gameState.currentWeapon = type;
            updateUI();
        }

        function checkAutoBuy() {
            if (gameState.coins >= 5) {
                gameState.coins -= 5;
                gameState.mineCount++;
                uiElements.mineHint.style.display = 'block';
                setTimeout(() => {
                    uiElements.mineHint.style.display = 'none';
                }, 3000);
                updateUI(); // Ensure UI updates when mine is bought
            }
        }

        function spawnEnemy() {
            if (gameState.bacteriaCount >= gameState.maxBacteria) return;

            let maxAttempts = 10;
            for(let i=0; i<maxAttempts; i++) {
                let c = Math.floor(Math.random() * (mapCols - 2)) + 1;
                let r = Math.floor(Math.random() * (mapRows - 2)) + 1;
                if (mapGrid[r][c] === 0) {
                     let dx = c*TILE_SIZE - player.x; let dy = r*TILE_SIZE - player.y;
                     if (Math.sqrt(dx*dx+dy*dy) > 300) {
                         enemies.push(new Bacteria(c, r));
                         gameState.bacteriaCount++;
                         let px = c * TILE_SIZE + TILE_SIZE/2; let py = r * TILE_SIZE + TILE_SIZE/2;
                         for(let j=0; j<8; j++) particles.push(new Particle(px, py, 'kill'));
                         break;
                     }
                }
            }
        }

        function spawnDirtyPipe() {
            if (gameState.pipesSpawned > gameState.maxPipes) return; // é™åˆ¶æ°´ç®¡ç¸½æ•¸

            let maxAttempts = 5;
            for(let i=0; i<maxAttempts; i++) {
                let c = Math.floor(Math.random() * (mapCols - 2)) + 1;
                let r = Math.floor(Math.random() * (mapRows - 2)) + 1;
                if (mapGrid[r][c] === 0 && Math.abs(player.x/TILE_SIZE - c) > 1) {
                     addObstacle(c, r, 'pipe', Math.random()>0.5?'horizontal':'vertical');
                     gameState.pipesSpawned++;
                     let px = c * TILE_SIZE + TILE_SIZE/2; let py = r * TILE_SIZE + TILE_SIZE/2;
                     for(let j=0; j<8; j++) particles.push(new Particle(px, py, 'dirt'));
                     break;
                }
            }
        }

        function checkWin() {
            // æª¢æŸ¥æ˜¯å¦é‚„æœ‰é«’æ°´ç®¡
            let dirtyPipes = obstacles.filter(p => p.type === 'pipe' && !p.markedForDeletion).length;
            let liveEnemies = enemies.length;

            uiElements.enemyCount.innerText = `å‰©é¤˜æ•µäºº: ${liveEnemies} | é«’æ°´ç®¡: ${dirtyPipes}`;

            // å¦‚æœç´°èŒå‡ºå®Œäº†ä¸”æ®ºå…‰äº†ï¼Œä¸”æ°´ç®¡ä¹Ÿæ²’äº† (ä¸”éŠæˆ²é€²è¡Œäº†ä¸€æ®µæ™‚é–“ä»¥ç¢ºä¿éƒ½ç”Ÿå‡ºä¾†äº†)
            // ç°¡å–®åˆ¤å®šï¼šå ´ä¸Šç„¡æ€ªç„¡ç®¡ï¼Œä¸”ç”Ÿæˆæ•¸å·²é”æ¨™
            if (dirtyPipes === 0 && liveEnemies === 0 && gameState.bacteriaCount >= gameState.maxBacteria) {
                endGame(true);
            }
        }

        function updateUI() {
            uiElements.hp.innerText = `HP: ${"â¤ï¸".repeat(player.hp)}`;
            uiElements.coins.innerText = gameState.coins;
            uiElements.mineBadge.innerText = gameState.mineCount;

            if (gameState.currentWeapon === 'normal') {
                uiElements.slotNormal.className = 'weapon-slot active';
                uiElements.slotSuper.className = 'weapon-slot';
            } else {
                uiElements.slotNormal.className = 'weapon-slot';
                uiElements.slotSuper.className = 'weapon-slot active';
            }

            checkWin();
        }

        function endGame(win) {
            gameState.running = false;
            uiElements.modalOver.style.display = 'flex';
            if (win) {
                uiElements.title.innerText = "ä»»å‹™å®Œæˆï¼";
                uiElements.title.className = "text-5xl font-black mb-2 text-green-500 drop-shadow-md";
                uiElements.msg.innerText = `æ°´æ•™å®˜æˆåŠŸæ·¨åŒ–äº†é€™ç‰‡å€åŸŸï¼`;
            } else {
                uiElements.title.innerText = "ä»»å‹™å¤±æ•—";
                uiElements.title.className = "text-5xl font-black mb-2 text-red-600 drop-shadow-md";
                uiElements.msg.innerText = `ç´°èŒèˆ‡é«’æ±™ç²å¾—äº†å‹åˆ©...`;
            }
        }

        window.restartGame = initGame;

        function gameLoop(timestamp) {
            if (!gameState.running) return;

            obstacles.forEach(o => o.update());
            mines.forEach(m => m.update());
            explosions.forEach(e => e.update());

            if (timestamp - gameState.lastFrameTime >= 1000) {
                gameState.time++;
                let mins = Math.floor(gameState.time / 60).toString().padStart(2, '0');
                let secs = (gameState.time % 60).toString().padStart(2, '0');
                uiElements.time.innerText = `${mins}:${secs}`;

                let spawnInterval = 5; if (gameState.time > 30) spawnInterval = 3;
                if (gameState.time % spawnInterval === 0) spawnEnemy();

                let pipeInterval = 6;
                if (gameState.time % pipeInterval === 0) spawnDirtyPipe();

                gameState.lastFrameTime = timestamp;
            }

            // æ¸…ç†é‚è¼¯
            obstacles.forEach(p => { if (p.markedForDeletion) mapGrid[p.r][p.c] = 0; });
            obstacles = obstacles.filter(p => !p.markedForDeletion);
            enemies = enemies.filter(e => e.active);
            mines = mines.filter(m => !m.exploded);
            explosions = explosions.filter(e => e.life > 0);

            player.update();
            projectiles.forEach(p => p.update());
            projectiles = projectiles.filter(p => p.active);
            enemies.forEach(e => e.update());
            particles.forEach(p => p.update());
            particles = particles.filter(p => p.life > 0);

            checkWin(); // æŒçºŒæª¢æŸ¥å‹åˆ©æ¢ä»¶
            draw();
            requestAnimationFrame(gameLoop);
        }

        function draw() {
            ctx.fillStyle = COLORS.bg; ctx.fillRect(0, 0, canvas.width, canvas.height);
            for (let r = 0; r < mapRows; r++) {
                for (let c = 0; c < mapCols; c++) {
                    if ((r + c) % 2 === 0) {
                        ctx.fillStyle = COLORS.grid; ctx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                }
            }

            ctx.save();
            ctx.shadowColor = 'rgba(0,0,0,0.1)'; ctx.shadowBlur = 10; ctx.shadowOffsetY = 5;
            obstacles.forEach(p => p.draw(ctx));
            mines.forEach(m => m.draw(ctx));
            ctx.restore();

            explosions.forEach(e => e.draw(ctx)); // çˆ†ç‚¸è¦åœ¨æœ€ä¸Šå±¤ä½†ä¸‹æ–¼è§’è‰²? ä¸ï¼Œçˆ†ç‚¸æ‡‰è©²è¦†è“‹
            enemies.forEach(e => e.draw(ctx));
            projectiles.forEach(p => p.draw(ctx));
            player.draw(ctx);
            particles.forEach(p => p.draw(ctx));
        }

        window.addEventListener('keydown', e => {
            keys[e.key] = true;
            if (e.key.toLowerCase() === 'b') player.placeMine();
            if (e.key === '1') switchWeapon('normal');
            if (e.key === '2') switchWeapon('super');
        });
        window.addEventListener('keyup', e => keys[e.key] = false);

        // Helper function to handle D-pad touch events
        const handleDpadTouch = (key, isPressed) => {
            keys[key] = isPressed;
        };

        // D-Pad setup
        const setupDpadBtn = (id, key) => {
            const btn = document.getElementById(id);
            btn.addEventListener('touchstart', (e) => { e.preventDefault(); handleDpadTouch(key, true); });
            btn.addEventListener('touchend', (e) => { e.preventDefault(); handleDpadTouch(key, false); });
            btn.addEventListener('mousedown', () => handleDpadTouch(key, true));
            btn.addEventListener('mouseup', () => handleDpadTouch(key, false));
            btn.addEventListener('mouseleave', () => handleDpadTouch(key, false)); // Handle mouse leaving button
        };

        setupDpadBtn('btn-up', 'ArrowUp');
        setupDpadBtn('btn-down', 'ArrowDown');
        setupDpadBtn('btn-left', 'ArrowLeft');
        setupDpadBtn('btn-right', 'ArrowRight');

        // Resize Logic
        window.addEventListener('resize', () => {
            resizeCanvas();
            // è‹¥éŠæˆ²é€²è¡Œä¸­ï¼Œå¯èƒ½éœ€è¦é‡ç¹ªä¸€æ¬¡
            if (!gameState.running) draw();
        });

        initGame();

    </script>
</body>
</html>
