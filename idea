<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>æ°´æ•™å®˜çš„å¤§å†’éšª </title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* * æ‰‹æ©ŸéŠæˆ²æ ¸å¿ƒ CSS 
         * ç¦æ­¢é¸å–ã€ç¦æ­¢æ»¾å‹•ã€å…¨è¢å¹•
         */
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: none; /* é—œéµï¼šç¦æ­¢ç€è¦½å™¨é è¨­è§¸æ§è¡Œç‚º */
            user-select: none;
            -webkit-user-select: none;
            font-family: 'Segoe UI', Tahoma, sans-serif;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #0f172a;
            position: fixed; /* é˜²æ­¢ iOS æ©¡çš®ç­‹æ•ˆæœ */
        }

        #game-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* UI å±¤ï¼šè¦†è“‹åœ¨ Canvas ä¸Š */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* è®“é»æ“Šç©¿é€åˆ°ä¸‹æ–¹ï¼Œé™¤éé»åˆ°æŒ‰éˆ• */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        /* é ‚éƒ¨è³‡è¨Šåˆ— */
        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 10px 16px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.6), transparent);
        }

        .stat-badge {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 20px;
            padding: 4px 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 800;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            font-size: 14px;
            border: 2px solid #e2e8f0;
        }

        /* è™›æ“¬æ§åˆ¶å™¨å€åŸŸ */
        .controls-area {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 20px 30px 40px 30px;
            pointer-events: auto; /* æ¢å¾©è§¸æ§ */
            height: 200px; /* æ„Ÿæ‡‰å€é«˜åº¦ */
        }

        /* æ–æ¡¿åŸºåº§ */
        .joystick-base {
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            position: relative;
            backdrop-filter: blur(2px);
        }
        
        /* æ–æ¡¿é ­ */
        .joystick-knob {
            width: 50px;
            height: 50px;
            background: rgba(59, 130, 246, 0.9);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.8);
            transition: transform 0.1s; /* å›å½ˆå‹•ç•« */
        }
        .joystick-knob.active {
            transition: none; /* æ‹–æ›³æ™‚ç„¡å»¶é² */
            background: #2563eb;
        }

        /* å‹•ä½œæŒ‰éˆ•ç¾¤ */
        .actions-cluster {
            display: flex;
            gap: 20px;
            align-items: flex-end;
        }

        .btn-circle {
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: white;
            box-shadow: 0 6px 15px rgba(0,0,0,0.4);
            border: 3px solid rgba(255,255,255,0.4);
            position: relative;
            touch-action: none;
            backdrop-filter: blur(4px);
        }
        
        .btn-circle:active {
            transform: scale(0.92);
            filter: brightness(1.2);
        }

        #btn-shoot {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
        }

        #btn-mine {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #ef4444, #b91c1c);
            margin-bottom: 20px; /* éŒ¯é–‹é«˜åº¦ */
        }

        .badge-count {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #fbbf24;
            color: #78350f;
            font-size: 12px;
            font-weight: bold;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 2px solid white;
        }

        /* æ¨¡æ…‹è¦–çª—é€šç”¨ */
        .modal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(8px);
            z-index: 50;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        .modal.show {
            opacity: 1;
            pointer-events: auto;
        }
        
        .modal-content {
            background: white;
            width: 85%;
            max-width: 400px;
            padding: 24px;
            border-radius: 24px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .modal.show .modal-content {
            transform: scale(1);
        }

        .btn-primary {
            background: #16a34a;
            color: white;
            width: 100%;
            padding: 14px;
            border-radius: 12px;
            font-size: 18px;
            font-weight: bold;
            border: none;
            box-shadow: 0 4px 0 #14532d;
            margin-top: 16px;
        }
        .btn-primary:active {
            transform: translateY(4px);
            box-shadow: none;
        }

        /* å‚·å®³/æ–‡å­—ç‰¹æ•ˆ */
        .floating-text {
            position: absolute;
            font-weight: bold;
            pointer-events: none;
            animation: floatUp 1s forwards;
            text-shadow: 1px 1px 0 #000;
        }
        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-40px) scale(1.2); opacity: 0; }
        }

        /* ä»»å‹™ç›®æ¨™æç¤º */
        .objective-toast {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: #fff;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0.8;
            white-space: nowrap;
        }

        /* æ©«å‘æ¨¡å¼æç¤º (å»ºè­°) */
        @media screen and (orientation: portrait) {
            .rotate-hint { display: none; } /* æš«æ™‚éš±è—ï¼Œå› ç‚ºåšäº†éŸ¿æ‡‰å¼ */
        }
    </style>
</head>
<body>

    <!-- éŠæˆ²ç•«å¸ƒ -->
    <canvas id="game-layer"></canvas>

    <!-- UI ä»‹é¢å±¤ -->
    <div id="ui-layer">
        
        <!-- é ‚éƒ¨è³‡è¨Š -->
        <div class="hud-top">
            <div class="flex gap-2">
                <div class="stat-badge text-red-600">
                    <span>â¤ï¸</span> <span id="hp-val">3</span>
                </div>
                <div class="stat-badge text-yellow-600">
                    <span>ğŸ’°</span> <span id="coin-val">0</span>
                </div>
            </div>
            <div class="stat-badge text-blue-600 min-w-[80px] justify-center">
                â±ï¸ <span id="time-val">00:00</span>
            </div>
        </div>

        <!-- ä»»å‹™æç¤º -->
        <div class="objective-toast" id="obj-text">
            ç›®æ¨™ï¼šæ¸…é™¤æ‰€æœ‰ç´°èŒ (0/10)
        </div>

        <!-- åº•éƒ¨æ§åˆ¶å™¨ (çµ•å°å®šä½) -->
        <div class="controls-area">
            <!-- è™›æ“¬æ–æ¡¿å€ -->
            <div class="joystick-base" id="joystick-zone">
                <div class="joystick-knob" id="joystick-knob"></div>
            </div>

            <!-- å‹•ä½œæŒ‰éˆ•å€ -->
            <div class="actions-cluster">
                <!-- åœ°é›·æŒ‰éˆ• -->
                <div class="btn-circle" id="btn-mine">
                    ğŸ’£
                    <div class="badge-count" id="mine-count">0</div>
                </div>
                <!-- å°„æ“ŠæŒ‰éˆ• -->
                <div class="btn-circle" id="btn-shoot">
                    ğŸ’¦
                </div>
            </div>
        </div>
    </div>

    <!-- é–‹å§‹/æš«åœé¸å–® -->
    <div id="start-modal" class="modal show">
        <div class="modal-content">
            <div class="text-4xl mb-2">ğŸš°</div>
            <h1 class="text-2xl font-black text-slate-800 mb-2">æ°´æ•™å®˜ç‰¹æ”»éšŠ</h1>
            <p class="text-slate-500 mb-4 text-sm">è¡Œå‹•ç‰ˆæ“ä½œèªªæ˜</p>
            
            <div class="bg-slate-100 p-4 rounded-xl text-left text-sm text-slate-700 space-y-2 mb-4">
                <div class="flex items-center gap-2">
                    <div class="w-6 h-6 rounded-full bg-slate-400 flex items-center justify-center text-white text-xs">L</div>
                    <span>å·¦å´æ–æ¡¿ç§»å‹•è§’è‰²</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-6 h-6 rounded-full bg-blue-500 flex items-center justify-center text-white text-xs">R</div>
                    <span>å³å´æŒ‰éˆ•ç™¼å°„é«˜å£“æ°´æŸ±</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-6 h-6 rounded-full bg-red-500 flex items-center justify-center text-white text-xs">B</div>
                    <span>ä½¿ç”¨ç‚¸å½ˆ (éœ€ 5 é‡‘å¹£)</span>
                </div>
            </div>

            <button class="btn-primary" onclick="Game.start()">é–‹å§‹ä»»å‹™</button>
        </div>
    </div>

    <!-- éŠæˆ²çµæŸè¦–çª— -->
    <div id="end-modal" class="modal">
        <div class="modal-content">
            <div id="end-icon" class="text-6xl mb-2">ğŸ†</div>
            <h2 id="end-title" class="text-3xl font-black text-slate-800 mb-2">ä»»å‹™å®Œæˆ</h2>
            <p id="end-msg" class="text-slate-600 mb-6 font-bold">å€åŸŸå·²æ·¨åŒ–ï¼</p>
            <button class="btn-primary" onclick="Game.restart()">å†æ¬¡æŒ‘æˆ°</button>
        </div>
    </div>

    <script>
        /**
         * éŠæˆ²ç³»çµ±æ ¸å¿ƒ
         * ä½¿ç”¨æ¨¡çµ„åŒ–çµæ§‹ç®¡ç†ï¼šInput(è¼¸å…¥), Render(æ¸²æŸ“), Logic(é‚è¼¯)
         */

        // --- å¸¸æ•¸è¨­å®š ---
        const CONFIG = {
            tileSize: 64,
            playerSpeed: 5,
            bulletSpeed: 10,
            colors: {
                bg: '#1e293b', // æ·±è‰²èƒŒæ™¯ï¼Œè®“éŠæˆ²å€äº®èµ·ä¾†
                floor1: '#f1f5f9',
                floor2: '#e2e8f0',
                wall: '#334155',
                water: '#3b82f6',
                enemy: '#16a34a',
                mine: '#ef4444'
            }
        };

        // --- è™›æ“¬æ–æ¡¿ç³»çµ± ---
        const Joystick = {
            active: false,
            origin: { x: 0, y: 0 },
            current: { x: 0, y: 0 },
            vector: { x: 0, y: 0 }, // æ­£è¦åŒ–å‘é‡ (-1 åˆ° 1)
            touchId: null,
            radius: 60, // æ–æ¡¿åŠå¾‘
            
            init() {
                const zone = document.getElementById('joystick-zone');
                const knob = document.getElementById('joystick-knob');
                
                // è§¸æ§é–‹å§‹
                zone.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.changedTouches[0];
                    this.touchId = touch.identifier;
                    this.active = true;
                    
                    const rect = zone.getBoundingClientRect();
                    // ä¸­å¿ƒé»
                    this.origin = { 
                        x: rect.left + rect.width / 2, 
                        y: rect.top + rect.height / 2 
                    };
                    
                    this.updatePosition(touch.clientX, touch.clientY);
                    knob.classList.add('active');
                }, { passive: false });

                // è§¸æ§ç§»å‹•
                zone.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    for(let i=0; i<e.changedTouches.length; i++) {
                        if(e.changedTouches[i].identifier === this.touchId) {
                            this.updatePosition(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
                            break;
                        }
                    }
                }, { passive: false });

                // è§¸æ§çµæŸ
                const endHandler = (e) => {
                    for(let i=0; i<e.changedTouches.length; i++) {
                        if(e.changedTouches[i].identifier === this.touchId) {
                            this.reset();
                            break;
                        }
                    }
                };
                zone.addEventListener('touchend', endHandler);
                zone.addEventListener('touchcancel', endHandler);
            },

            updatePosition(clientX, clientY) {
                const knob = document.getElementById('joystick-knob');
                
                let dx = clientX - this.origin.x;
                let dy = clientY - this.origin.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                // é™åˆ¶åœ¨åœ“åœˆå…§
                if (distance > this.radius) {
                    const angle = Math.atan2(dy, dx);
                    dx = Math.cos(angle) * this.radius;
                    dy = Math.sin(angle) * this.radius;
                }

                // è¨ˆç®—æ­£è¦åŒ–å‘é‡ (ç”¨æ–¼è§’è‰²ç§»å‹•)
                this.vector.x = dx / this.radius;
                this.vector.y = dy / this.radius;

                // æ›´æ–° UI
                knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            },

            reset() {
                this.active = false;
                this.touchId = null;
                this.vector = { x: 0, y: 0 };
                const knob = document.getElementById('joystick-knob');
                knob.style.transform = `translate(-50%, -50%)`;
                knob.classList.remove('active');
            }
        };

        // --- é¡é ­ç³»çµ± ---
        const Camera = {
            x: 0, y: 0,
            follow(target) {
                // è®“ç›®æ¨™ä¿æŒåœ¨è¢å¹•ä¸­å¿ƒ
                this.x = target.x - canvas.width / 2;
                this.y = target.y - canvas.height / 2;
                
                // é‚Šç•Œé™åˆ¶ (ä¸è®“é¡é ­çœ‹å‡ºå»å¤–é¢)
                const mapW = Game.mapCols * CONFIG.tileSize;
                const mapH = Game.mapRows * CONFIG.tileSize;
                
                this.x = Math.max(0, Math.min(this.x, mapW - canvas.width));
                this.y = Math.max(0, Math.min(this.y, mapH - canvas.height));
                
                // å¦‚æœåœ°åœ–æ¯”è¢å¹•å°ï¼Œç½®ä¸­
                if (mapW < canvas.width) this.x = -(canvas.width - mapW) / 2;
                if (mapH < canvas.height) this.y = -(canvas.height - mapH) / 2;
            }
        };

        // --- éŠæˆ²ä¸»é«” ---
        const canvas = document.getElementById('game-layer');
        const ctx = canvas.getContext('2d');

        const Game = {
            running: false,
            lastTime: 0,
            timeElapsed: 0,
            
            // åœ°åœ–èˆ‡å¯¦é«”
            mapCols: 30, // æ“´å¤§åœ°åœ–
            mapRows: 30,
            grid: [],
            entities: [],
            particles: [],
            obstacles: [],
            
            // ç‹€æ…‹
            coins: 0,
            mineCount: 0,
            enemiesKilled: 0,
            totalEnemies: 20,
            
            init() {
                this.resize();
                Joystick.init();
                
                // æŒ‰éˆ•ç¶å®š
                const btnShoot = document.getElementById('btn-shoot');
                const btnMine = document.getElementById('btn-mine');
                
                // æ”¯æ´é€£ç™¼ (æŒ‰ä½)
                let shootInterval;
                const startShoot = (e) => {
                    e.preventDefault();
                    if(!this.running) return;
                    this.player.shoot();
                    shootInterval = setInterval(() => this.player.shoot(), 200);
                    btnShoot.style.transform = 'scale(0.9)';
                };
                const stopShoot = (e) => {
                    e.preventDefault();
                    clearInterval(shootInterval);
                    btnShoot.style.transform = 'scale(1)';
                };

                btnShoot.addEventListener('touchstart', startShoot);
                btnShoot.addEventListener('touchend', stopShoot);
                btnShoot.addEventListener('mousedown', startShoot);
                btnShoot.addEventListener('mouseup', stopShoot);

                // åœ°é›· (å–®é»)
                const placeMine = (e) => {
                    e.preventDefault();
                    if(!this.running) return;
                    this.player.placeMine();
                    btnMine.style.transform = 'scale(0.9)';
                    setTimeout(() => btnMine.style.transform = 'scale(1)', 100);
                };
                btnMine.addEventListener('touchstart', placeMine);
                btnMine.addEventListener('mousedown', placeMine);

                window.addEventListener('resize', () => this.resize());
            },

            resize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                ctx.imageSmoothingEnabled = false; // åƒç´ é¢¨æ ¼
            },

            start() {
                document.getElementById('start-modal').classList.remove('show');
                document.getElementById('end-modal').classList.remove('show');
                
                this.running = true;
                this.coins = 0;
                this.mineCount = 0;
                this.timeElapsed = 0;
                this.enemiesKilled = 0;
                this.particles = [];
                this.obstacles = [];
                this.entities = [];
                
                // ç”Ÿæˆåœ°åœ–
                this.generateLevel();
                
                // å‰µå»ºç©å®¶
                this.player = new Player(CONFIG.tileSize * 2, CONFIG.tileSize * 2);
                this.entities.push(this.player);

                // åˆå§‹æ•µäºº
                for(let i=0; i<5; i++) this.spawnEnemy();

                this.lastTime = performance.now();
                requestAnimationFrame((t) => this.loop(t));
                this.updateUI();
            },

            restart() {
                this.start();
            },

            generateLevel() {
                this.grid = [];
                for(let r=0; r<this.mapRows; r++) {
                    let row = [];
                    for(let c=0; c<this.mapCols; c++) {
                        // é‚Šç•Œç‰†
                        if(r===0 || r===this.mapRows-1 || c===0 || c===this.mapCols-1) {
                            row.push(1);
                            this.obstacles.push(new Wall(c*CONFIG.tileSize, r*CONFIG.tileSize));
                        } else {
                            // éš¨æ©Ÿéšœç¤™ç‰©
                            if (Math.random() < 0.1 && (r > 4 || c > 4)) {
                                row.push(1); // 1 = ç‰†
                                this.obstacles.push(new Pipe(c*CONFIG.tileSize, r*CONFIG.tileSize));
                            } else {
                                row.push(0); // 0 = åœ°æ¿
                            }
                        }
                    }
                    this.grid.push(row);
                }
            },

            spawnEnemy() {
                let x, y, c, r;
                let attempts = 0;
                do {
                    c = Math.floor(Math.random() * (this.mapCols - 2)) + 1;
                    r = Math.floor(Math.random() * (this.mapRows - 2)) + 1;
                    x = c * CONFIG.tileSize;
                    y = r * CONFIG.tileSize;
                    attempts++;
                    // ç¢ºä¿é›¢ç©å®¶å¤ é 
                    let dist = Math.hypot(x - this.player.x, y - this.player.y);
                    if (this.grid[r][c] === 0 && dist > 400) break;
                } while (attempts < 50);

                if (attempts < 50) {
                    this.entities.push(new Enemy(x + 10, y + 10));
                }
            },

            loop(now) {
                if (!this.running) return;
                const dt = (now - this.lastTime) / 1000;
                this.lastTime = now;

                this.update(dt);
                this.draw();

                requestAnimationFrame((t) => this.loop(t));
            },

            update(dt) {
                // æ™‚é–“é‚è¼¯
                if (Math.floor(now/1000) > this.timeElapsed) {
                    this.timeElapsed++;
                    if (this.timeElapsed % 2 === 0 && this.entities.filter(e => e.type === 'enemy').length < 15) {
                        this.spawnEnemy();
                    }
                }
                document.getElementById('time-val').innerText = 
                    Math.floor(this.timeElapsed/60).toString().padStart(2,'0') + ':' + 
                    (this.timeElapsed%60).toString().padStart(2,'0');

                // é¡é ­è·Ÿéš¨
                Camera.follow(this.player);

                // å¯¦é«”æ›´æ–°
                this.entities.forEach(e => e.update(dt));
                this.obstacles.forEach(o => o.update(dt));
                
                // ç²’å­æ›´æ–°
                this.particles.forEach(p => p.update(dt));
                this.particles = this.particles.filter(p => p.life > 0);

                // æ¸…ç†æ­»äº¡å¯¦é«”
                this.entities = this.entities.filter(e => !e.dead);
                this.obstacles = this.obstacles.filter(o => !o.dead);

                // å‹åˆ©/å¤±æ•—æª¢æŸ¥
                if (this.player.hp <= 0) this.gameOver(false);
                if (this.enemiesKilled >= this.totalEnemies) this.gameOver(true);
                
                // æ›´æ–°ä»»å‹™æ–‡å­—
                document.getElementById('obj-text').innerText = `ç›®æ¨™ï¼šæ¸…é™¤ç´°èŒ (${this.enemiesKilled}/${this.totalEnemies})`;
            },

            draw() {
                // æ¸…ç©ºç•«å¸ƒ
                ctx.fillStyle = CONFIG.colors.bg;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.save();
                // æ‡‰ç”¨é¡é ­ä½ç§»
                ctx.translate(-Camera.x, -Camera.y);

                // ç¹ªè£½åœ°æ¿ (åƒ…ç¹ªè£½è¦–é‡å…§çš„)
                const startCol = Math.floor(Camera.x / CONFIG.tileSize);
                const endCol = startCol + (canvas.width / CONFIG.tileSize) + 1;
                const startRow = Math.floor(Camera.y / CONFIG.tileSize);
                const endRow = startRow + (canvas.height / CONFIG.tileSize) + 1;

                for (let r = startRow; r <= endRow; r++) {
                    for (let c = startCol; c <= endCol; c++) {
                        if (r >= 0 && r < this.mapRows && c >= 0 && c < this.mapCols) {
                            if (this.grid[r][c] === 0) {
                                ctx.fillStyle = (r+c)%2===0 ? CONFIG.colors.floor1 : CONFIG.colors.floor2;
                                ctx.fillRect(c*CONFIG.tileSize, r*CONFIG.tileSize, CONFIG.tileSize, CONFIG.tileSize);
                            }
                        }
                    }
                }

                // ç¹ªè£½ç‰©é«”
                // æŒ‰Yè»¸æ’åºä»¥ç”¢ç”Ÿæ­£ç¢ºçš„é®æ“‹é—œä¿‚
                const renderList = [...this.obstacles, ...this.entities, ...this.particles];
                renderList.sort((a, b) => (a.y + a.h) - (b.y + b.h));

                renderList.forEach(obj => obj.draw(ctx));

                ctx.restore();
            },

            shakeScreen() {
                const intensity = 10;
                canvas.style.transform = `translate(${Math.random()*intensity - intensity/2}px, ${Math.random()*intensity - intensity/2}px)`;
                setTimeout(() => canvas.style.transform = 'none', 50);
            },

            addFloatingText(x, y, text, color) {
                const el = document.createElement('div');
                el.className = 'floating-text';
                el.style.left = (x - Camera.x) + 'px'; // è½‰æ›ç‚ºè¢å¹•åº§æ¨™
                el.style.top = (y - Camera.y) + 'px';
                el.style.color = color;
                el.innerText = text;
                document.getElementById('game-layer').parentNode.appendChild(el); // Append to body
                setTimeout(() => el.remove(), 1000);
            },

            updateUI() {
                document.getElementById('hp-val').innerText = this.player.hp;
                document.getElementById('coin-val').innerText = this.coins;
                document.getElementById('mine-count').innerText = this.mineCount;
                if (this.coins >= 5) {
                     document.getElementById('btn-mine').style.borderColor = '#fbbf24';
                } else {
                     document.getElementById('btn-mine').style.borderColor = 'rgba(255,255,255,0.4)';
                }
            },

            gameOver(win) {
                this.running = false;
                const modal = document.getElementById('end-modal');
                const title = document.getElementById('end-title');
                const msg = document.getElementById('end-msg');
                const icon = document.getElementById('end-icon');

                modal.classList.add('show');
                if (win) {
                    icon.innerText = "ğŸ‰";
                    title.innerText = "ä»»å‹™å®Œæˆï¼";
                    title.className = "text-3xl font-black text-green-600 mb-2";
                    msg.innerText = `æ°´æ•™å®˜æˆåŠŸå®ˆè­·äº†æ°´æºï¼`;
                } else {
                    icon.innerText = "â˜ ï¸";
                    title.innerText = "ä»»å‹™å¤±æ•—";
                    title.className = "text-3xl font-black text-red-600 mb-2";
                    msg.innerText = `ç´°èŒä½”é ˜äº†é€™ç‰‡å€åŸŸ...`;
                }
            }
        };

        const now = Date.now();

        // --- é¡åˆ¥å®šç¾© ---

        class Entity {
            constructor(x, y, w, h) {
                this.x = x; this.y = y; this.w = w; this.h = h;
                this.vx = 0; this.vy = 0;
                this.dead = false;
                this.type = 'entity';
            }
            update(dt) {
                this.x += this.vx;
                this.y += this.vy;
            }
            draw(ctx) {}
            get center() { return { x: this.x + this.w/2, y: this.y + this.h/2 }; }
            
            checkCollision(other) {
                return (this.x < other.x + other.w &&
                        this.x + this.w > other.x &&
                        this.y < other.y + other.h &&
                        this.y + this.h > other.y);
            }
        }

        class Player extends Entity {
            constructor(x, y) {
                super(x, y, 40, 40);
                this.hp = 5;
                this.speed = 250;
                this.lastShot = 0;
                this.facing = {x: 0, y: 1};
                this.invincible = 0;
            }

            update(dt) {
                // å¾è™›æ“¬æ–æ¡¿ç²å–è¼¸å…¥
                if (Joystick.active) {
                    this.vx = Joystick.vector.x * this.speed * dt;
                    this.vy = Joystick.vector.y * this.speed * dt;
                    if (Math.abs(Joystick.vector.x) > 0.1 || Math.abs(Joystick.vector.y) > 0.1) {
                         this.facing = { ...Joystick.vector };
                    }
                } else {
                    this.vx = 0; this.vy = 0;
                }

                // ç¢°æ’æª¢æ¸¬ (ç°¡å–®ç‰ˆï¼šé æ¸¬ä¸‹ä¸€æ­¥)
                if (!this.isValidMove(this.x + this.vx, this.y)) this.vx = 0;
                if (!this.isValidMove(this.x, this.y + this.vy)) this.vy = 0;

                super.update(dt);
                
                // é‚Šç•Œé™åˆ¶
                this.x = Math.max(0, Math.min(this.x, Game.mapCols*CONFIG.tileSize - this.w));
                this.y = Math.max(0, Math.min(this.y, Game.mapRows*CONFIG.tileSize - this.h));

                if (this.invincible > 0) this.invincible -= dt;

                // æ’¿é‡‘å¹£
                Game.particles.forEach(p => {
                    if (p.type === 'coin' && this.checkCollision({x:p.x-10, y:p.y-10, w:20, h:20})) {
                        p.life = 0;
                        Game.coins++;
                        Game.updateUI();
                    }
                });
            }

            isValidMove(nx, ny) {
                // æª¢æŸ¥å››å€‹è§’
                const padding = 5;
                const points = [
                    {c: Math.floor((nx+padding)/CONFIG.tileSize), r: Math.floor((ny+padding)/CONFIG.tileSize)},
                    {c: Math.floor((nx+this.w-padding)/CONFIG.tileSize), r: Math.floor((ny+padding)/CONFIG.tileSize)},
                    {c: Math.floor((nx+padding)/CONFIG.tileSize), r: Math.floor((ny+this.h-padding)/CONFIG.tileSize)},
                    {c: Math.floor((nx+this.w-padding)/CONFIG.tileSize), r: Math.floor((ny+this.h-padding)/CONFIG.tileSize)}
                ];
                return points.every(p => Game.grid[p.r] && Game.grid[p.r][p.c] === 0);
            }

            shoot() {
                const now = Date.now();
                if (now - this.lastShot > 250) {
                    this.lastShot = now;
                    // æ­£è¦åŒ–ç™¼å°„æ–¹å‘
                    let mag = Math.sqrt(this.facing.x**2 + this.facing.y**2);
                    if (mag === 0) mag = 1; 
                    
                    Game.entities.push(new Bullet(
                        this.center.x, this.center.y, 
                        (this.facing.x/mag), (this.facing.y/mag)
                    ));
                }
            }

            placeMine() {
                if (Game.coins >= 5) {
                    Game.coins -= 5;
                    Game.entities.push(new Mine(this.center.x, this.center.y));
                    Game.mineCount++;
                    Game.updateUI();
                    Game.addFloatingText(this.x, this.y, "-5ğŸ’°", "#fbbf24");
                } else {
                    Game.addFloatingText(this.x, this.y, "é‡‘å¹£ä¸è¶³", "#ef4444");
                }
            }
            
            takeDamage(amt) {
                if (this.invincible > 0) return;
                this.hp -= amt;
                this.invincible = 1.0;
                Game.shakeScreen();
                Game.updateUI();
                Game.addFloatingText(this.x, this.y, "-1 HP", "#ef4444");
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.center.x, this.center.y);
                if (this.invincible > 0 && Math.floor(Date.now()/100)%2) ctx.globalAlpha = 0.5;

                // ç°¡å–®çš„è§’è‰²ç¹ªè£½
                // èº«é«”
                ctx.fillStyle = '#3b82f6';
                ctx.beginPath(); ctx.arc(0, 0, 18, 0, Math.PI*2); ctx.fill();
                // çœ¼ç› (æ ¹æ“šæœå‘)
                const eyeX = this.facing.x * 8;
                const eyeY = this.facing.y * 8 - 4;
                ctx.fillStyle = 'white';
                ctx.beginPath(); ctx.arc(eyeX - 5, eyeY, 5, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(eyeX + 5, eyeY, 5, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'black';
                ctx.beginPath(); ctx.arc(eyeX - 5, eyeY, 2, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(eyeX + 5, eyeY, 2, 0, Math.PI*2); ctx.fill();
                // å¸½å­
                ctx.fillStyle = '#1e3a8a';
                ctx.beginPath(); ctx.arc(0, -5, 18, Math.PI, 0); ctx.fill();
                ctx.restore();
            }
        }

        class Enemy extends Entity {
            constructor(x, y) {
                super(x, y, 40, 40);
                this.speed = 100 + Math.random() * 50;
                this.hp = 3;
                this.type = 'enemy';
            }
            
            update(dt) {
                const p = Game.player;
                const dx = p.x - this.x;
                const dy = p.y - this.y;
                const dist = Math.hypot(dx, dy);
                
                if (dist > 0) {
                    this.vx = (dx / dist) * this.speed * dt;
                    this.vy = (dy / dist) * this.speed * dt;
                }

                // ç°¡å–®ç¢°æ’æ¨æ“ 
                Game.entities.forEach(e => {
                    if (e !== this && e.type === 'enemy' && this.checkCollision(e)) {
                        this.vx -= (e.x - this.x) * 2 * dt;
                        this.vy -= (e.y - this.y) * 2 * dt;
                    }
                });

                this.x += this.vx;
                this.y += this.vy;

                // æ”»æ“Šç©å®¶
                if (this.checkCollision(p)) {
                    p.takeDamage(1);
                }
            }

            takeDamage(amt) {
                this.hp -= amt;
                if (this.hp <= 0) {
                    this.dead = true;
                    Game.enemiesKilled++;
                    // æ‰è½é‡‘å¹£ (ç²’å­)
                    Game.particles.push(new Particle(this.center.x, this.center.y, 'coin'));
                    // æ­»äº¡ç‰¹æ•ˆ
                    for(let i=0; i<5; i++) {
                         Game.particles.push(new Particle(this.center.x, this.center.y, 'goo'));
                    }
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.center.x, this.center.y);
                // å²èŠå§†æ™ƒå‹•æ•ˆæœ
                const scale = 1 + Math.sin(Date.now() / 200) * 0.1;
                ctx.scale(scale, 1/scale);
                
                ctx.fillStyle = CONFIG.colors.enemy;
                ctx.beginPath();
                ctx.arc(0, 0, 15, Math.PI, 0); // ä¸ŠåŠåœ“
                // åº•éƒ¨æ³¢æµª
                ctx.lineTo(15, 10); 
                ctx.lineTo(0, 15);
                ctx.lineTo(-15, 10);
                ctx.fill();
                
                // é‚ªæƒ¡è¡¨æƒ…
                ctx.fillStyle = '#064e3b';
                ctx.beginPath(); ctx.moveTo(-8, -5); ctx.lineTo(-2, 0); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(8, -5); ctx.lineTo(2, 0); ctx.stroke();
                
                ctx.restore();
                
                // è¡€æ¢
                ctx.fillStyle = 'red';
                ctx.fillRect(this.x, this.y - 10, this.w, 4);
                ctx.fillStyle = '#22c55e';
                ctx.fillRect(this.x, this.y - 10, this.w * (this.hp/3), 4);
            }
        }

        class Bullet extends Entity {
            constructor(x, y, dx, dy) {
                super(x, y, 10, 10);
                this.vx = dx * 500;
                this.vy = dy * 500;
                this.life = 1.0;
            }
            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.life -= dt;
                if (this.life <= 0) this.dead = true;

                // æ’ç‰†
                let c = Math.floor(this.center.x / CONFIG.tileSize);
                let r = Math.floor(this.center.y / CONFIG.tileSize);
                if (Game.grid[r] && Game.grid[r][c] === 1) {
                    this.dead = true;
                    Game.particles.push(new Particle(this.x, this.y, 'water'));
                }

                // æ’æ•µäºº
                Game.entities.forEach(e => {
                    if (e.type === 'enemy' && this.checkCollision(e)) {
                        e.takeDamage(1);
                        this.dead = true;
                        Game.particles.push(new Particle(this.x, this.y, 'water'));
                    }
                });
            }
            draw(ctx) {
                ctx.fillStyle = '#60a5fa';
                ctx.beginPath(); ctx.arc(this.x, this.y, 6, 0, Math.PI*2); ctx.fill();
            }
        }

        class Mine extends Entity {
            constructor(x, y) {
                super(x - 15, y - 15, 30, 30);
                this.timer = 2.0;
            }
            update(dt) {
                this.timer -= dt;
                if (this.timer <= 0) {
                    this.dead = true;
                    this.explode();
                }
            }
            explode() {
                Game.shakeScreen();
                Game.mineCount--;
                Game.updateUI();
                // ç¯„åœå‚·å®³
                const radius = 100;
                Game.entities.forEach(e => {
                    if (e.type === 'enemy') {
                        const dist = Math.hypot(e.center.x - this.center.x, e.center.y - this.center.y);
                        if (dist < radius) e.takeDamage(5); // ç§’æ®º
                    }
                });
                // ç ´å£æ°´ç®¡
                Game.obstacles.forEach(o => {
                    if (o instanceof Pipe) {
                        const dist = Math.hypot(o.x - this.center.x, o.y - this.center.y);
                        if (dist < radius) o.clean();
                    }
                });
                // ç‰¹æ•ˆ
                for(let i=0; i<10; i++) Game.particles.push(new Particle(this.center.x, this.center.y, 'explosion'));
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.center.x, this.center.y);
                const pulse = Math.sin(Date.now()/50) * 0.2 + 1;
                ctx.scale(pulse, pulse);
                ctx.fillStyle = '#ef4444';
                ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'black';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(Math.ceil(this.timer), 0, 4);
                ctx.restore();
            }
        }

        class Wall {
            constructor(x, y) {
                this.x = x; this.y = y; this.w = CONFIG.tileSize; this.h = CONFIG.tileSize;
                this.dead = false;
            }
            update(dt) {}
            draw(ctx) {
                ctx.fillStyle = CONFIG.colors.wall;
                ctx.fillRect(this.x, this.y, this.w, this.h);
                ctx.fillStyle = '#475569'; // Highlight
                ctx.fillRect(this.x, this.y, this.w, 5);
            }
        }

        class Pipe extends Wall {
            constructor(x, y) {
                super(x, y);
                this.dirty = true;
            }
            clean() {
                if (this.dirty) {
                    this.dirty = false;
                    this.dead = true; // è®Šæˆåœ°æ¿
                    // æ›´æ–° grid
                    let c = this.x / CONFIG.tileSize;
                    let r = this.y / CONFIG.tileSize;
                    Game.grid[r][c] = 0;
                    Game.particles.push(new Particle(this.x + this.w/2, this.y + this.h/2, 'coin'));
                    Game.coins += 2; // çå‹µ
                    Game.updateUI();
                }
            }
            draw(ctx) {
                ctx.fillStyle = '#94a3b8';
                ctx.fillRect(this.x+5, this.y+5, this.w-10, this.h-10);
                if (this.dirty) {
                    ctx.fillStyle = '#854d0e'; // é«’æ±¡
                    ctx.beginPath(); ctx.arc(this.x+this.w/2, this.y+this.h/2, 10, 0, Math.PI*2); ctx.fill();
                    // å†’ç…™
                    if (Math.random() < 0.05) {
                        Game.particles.push(new Particle(this.x+this.w/2, this.y+this.h/2, 'goo'));
                    }
                }
            }
        }

        class Particle {
            constructor(x, y, type) {
                this.x = x; this.y = y;
                this.type = type;
                this.life = 1.0;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 100;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                
                if (type === 'coin') {
                    this.vy = -50; this.vx = 0;
                }
            }
            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.life -= dt;
            }
            draw(ctx) {
                ctx.globalAlpha = this.life;
                if (this.type === 'water') {
                    ctx.fillStyle = '#bae6fd';
                    ctx.beginPath(); ctx.arc(this.x, this.y, 4, 0, Math.PI*2); ctx.fill();
                } else if (this.type === 'goo') {
                    ctx.fillStyle = '#a3e635';
                    ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI*2); ctx.fill();
                } else if (this.type === 'explosion') {
                    ctx.fillStyle = '#fca5a5';
                    ctx.beginPath(); ctx.arc(this.x, this.y, 10 * this.life, 0, Math.PI*2); ctx.fill();
                } else if (this.type === 'coin') {
                    ctx.font = '20px Arial';
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillText('ğŸ’°', this.x, this.y);
                }
                ctx.globalAlpha = 1.0;
            }
        }

        // --- å•Ÿå‹• ---
        window.onload = () => {
            Game.init();
        };

    </script>
</body>
</html>
