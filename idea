<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>æ°´æ•™å®˜çš„å¤§å†’éšª </title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* * æ‰‹æ©ŸéŠæˆ²æ ¸å¿ƒ CSS 
         * ç¦æ­¢é¸å–ã€ç¦æ­¢æ»¾å‹•ã€å…¨è¢å¹•
         */
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: none; /* é—œéµï¼šç¦æ­¢ç€è¦½å™¨é è¨­è§¸æ§è¡Œç‚º */
            user-select: none;
            -webkit-user-select: none;
            font-family: 'Segoe UI', Tahoma, sans-serif;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #0f172a;
            position: fixed; /* é˜²æ­¢ iOS æ©¡çš®ç­‹æ•ˆæœ */
        }

        #game-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* UI å±¤ï¼šè¦†è“‹åœ¨ Canvas ä¸Š */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* è®“é»æ“Šç©¿é€åˆ°ä¸‹æ–¹ï¼Œé™¤éé»åˆ°æŒ‰éˆ• */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        /* é ‚éƒ¨è³‡è¨Šåˆ— */
        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 10px 16px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.6), transparent);
        }

        .stat-badge {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 20px;
            padding: 4px 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 800;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            font-size: 14px;
            border: 2px solid #e2e8f0;
        }

        /* è™›æ“¬æ§åˆ¶å™¨å€åŸŸ */
        .controls-area {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 20px 30px 40px 30px;
            pointer-events: auto; /* æ¢å¾©è§¸æ§ */
            height: 200px; /* æ„Ÿæ‡‰å€é«˜åº¦ */
        }

        /* æ–æ¡¿åŸºåº§ */
        .joystick-base {
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            position: relative;
            backdrop-filter: blur(2px);
        }
        
        /* æ–æ¡¿é ­ */
        .joystick-knob {
            width: 50px;
            height: 50px;
            background: rgba(59, 130, 246, 0.9);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.8);
            transition: transform 0.1s; /* å›å½ˆå‹•ç•« */
        }
        .joystick-knob.active {
            transition: none; /* æ‹–æ›³æ™‚ç„¡å»¶é² */
            background: #2563eb;
        }

        /* å‹•ä½œæŒ‰éˆ•ç¾¤ */
        .actions-cluster {
            display: flex;
            gap: 20px;
            align-items: flex-end;
        }

        .btn-circle {
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: white;
            box-shadow: 0 6px 15px rgba(0,0,0,0.4);
            border: 3px solid rgba(255,255,255,0.4);
            position: relative;
            touch-action: none;
            backdrop-filter: blur(4px);
        }
        
        .btn-circle:active {
            transform: scale(0.92);
            filter: brightness(1.2);
        }

        #btn-shoot {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
        }

        #btn-mine {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #ef4444, #b91c1c);
            margin-bottom: 20px; /* éŒ¯é–‹é«˜åº¦ */
        }

        .badge-count {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #fbbf24;
            color: #78350f;
            font-size: 12px;
            font-weight: bold;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 2px solid white;
        }

        /* æ¨¡æ…‹è¦–çª—é€šç”¨ */
        .modal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(8px);
            z-index: 50;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        .modal.show {
            opacity: 1;
            pointer-events: auto;
        }
        
        .modal-content {
            background: white;
            width: 85%;
            max-width: 400px;
            padding: 24px;
            border-radius: 24px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .modal.show .modal-content {
            transform: scale(1);
        }

        .btn-primary {
            background: #16a34a;
            color: white;
            width: 100%;
            padding: 14px;
            border-radius: 12px;
            font-size: 18px;
            font-weight: bold;
            border: none;
            box-shadow: 0 4px 0 #14532d;
            margin-top: 16px;
        }
        .btn-primary:active {
            transform: translateY(4px);
            box-shadow: none;
        }

        /* å‚·å®³/æ–‡å­—ç‰¹æ•ˆ */
        .floating-text {
            position: absolute;
            font-weight: bold;
            pointer-events: none;
            animation: floatUp 1s forwards;
            text-shadow: 1px 1px 0 #000;
        }
        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-40px) scale(1.2); opacity: 0; }
        }

        /* ä»»å‹™ç›®æ¨™æç¤º */
        .objective-toast {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: #fff;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0.8;
            white-space: nowrap;
        }

        /* æ©«å‘æ¨¡å¼æç¤º (å»ºè­°) */
        @media screen and (orientation: portrait) {
            .rotate-hint { display: none; } /* æš«æ™‚éš±è—ï¼Œå› ç‚ºåšäº†éŸ¿æ‡‰å¼ */
        }
    </style>
</head>
<body>

    <!-- éŠæˆ²ç•«å¸ƒ -->
    <canvas id="game-layer"></canvas>

    <!-- UI ä»‹é¢å±¤ -->
    <div id="ui-layer">
        
        <!-- é ‚éƒ¨è³‡è¨Š -->
        <div class="hud-top">
            <div class="flex gap-2">
                <div class="stat-badge text-red-600">
                    <span>â¤ï¸</span> <span id="hp-val">3</span>
                </div>
                <div class="stat-badge text-gray-600">
                     <span>ğŸ’£</span> <span id="mine-val">0</span>
                </div>
            </div>
            <div class="stat-badge text-blue-600 min-w-[80px] justify-center">
                â±ï¸ <span id="time-val">00:00</span>
            </div>
        </div>

        <!-- ä»»å‹™æç¤º -->
        <div class="objective-toast" id="obj-text">
            ç›®æ¨™ï¼šæ¸…é™¤æ‰€æœ‰ç´°èŒ (0/10)
        </div>

        <!-- åº•éƒ¨æ§åˆ¶å™¨ (çµ•å°å®šä½) -->
        <div class="controls-area">
            <!-- è™›æ“¬æ–æ¡¿å€ -->
            <div class="joystick-base" id="joystick-zone">
                <div class="joystick-knob" id="joystick-knob"></div>
            </div>

            <!-- å‹•ä½œæŒ‰éˆ•å€ -->
            <div class="actions-cluster">
                <!-- åœ°é›·æŒ‰éˆ• -->
                <div class="btn-circle" id="btn-mine">
                    ğŸ’£
                    <div class="badge-count" id="mine-count">0</div>
                </div>
                <!-- å°„æ“ŠæŒ‰éˆ• -->
                <div class="btn-circle" id="btn-shoot">
                    ğŸ’¦
                </div>
            </div>
        </div>
    </div>

    <!-- é–‹å§‹/æš«åœé¸å–® -->
    <div id="start-modal" class="modal show">
        <div class="modal-content">
            <div class="text-4xl mb-2">ğŸš°</div>
            <h1 class="text-2xl font-black text-slate-800 mb-2">æ°´æ•™å®˜ï¼šæ·±å±¤æ·¨åŒ–</h1>
            <p class="text-slate-500 mb-4 text-sm">æ°´ç®¡å¤§å µå¡ï¼æº–å‚™å¼·åŠ›æ²–æ´—ï¼</p>
            
            <div class="bg-slate-100 p-4 rounded-xl text-left text-sm text-slate-700 space-y-2 mb-4">
                <div class="flex items-center gap-2">
                    <div class="w-6 h-6 rounded-full bg-blue-500 flex items-center justify-center text-white text-xs">R</div>
                    <span>ç™¼å°„æ°´æŸ±<strong class="text-blue-600">æ²–æ´—å µå¡æ°´ç®¡</strong></span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-6 h-6 rounded-full bg-green-600 flex items-center justify-center text-white text-xs">!</div>
                    <span>ç´°èŒæœƒ<strong class="text-green-600">å…¨åœ°åœ–éŠè•©</strong>ï¼Œé è¿‘æ‰æ”»æ“Šï¼</span>
                </div>
                <div class="flex items-center gap-2">
                    <span class="text-xl">âœ¨</span>
                    <span>æ°´ç®¡ä¹¾æ·¨å¾Œç™¼å°„<strong class="text-yellow-600">å…‰æ³¢</strong>ä¸¦ç²å¾—åœ°é›·ï¼</span>
                </div>
            </div>

            <button class="btn-primary" onclick="Game.start()">é–‹å§‹æ·¨åŒ–</button>
        </div>
    </div>

    <!-- éŠæˆ²çµæŸè¦–çª— -->
    <div id="end-modal" class="modal">
        <div class="modal-content">
            <div id="end-icon" class="text-6xl mb-2">ğŸ†</div>
            <h2 id="end-title" class="text-3xl font-black text-slate-800 mb-2">ä»»å‹™å®Œæˆ</h2>
            <p id="end-msg" class="text-slate-600 mb-6 font-bold">å€åŸŸå·²æ·¨åŒ–ï¼</p>
            <button class="btn-primary" onclick="Game.restart()">å†æ¬¡æŒ‘æˆ°</button>
        </div>
    </div>

    <script>
        /**
         * éŠæˆ²ç³»çµ±æ ¸å¿ƒ
         */

        // --- å¸¸æ•¸è¨­å®š ---
        const CONFIG = {
            tileSize: 64,
            playerSpeed: 250,
            enemySpeed: 180,
            enemyWanderSpeed: 50, // éŠè•©é€Ÿåº¦è¼ƒæ…¢
            enemyAggroRange: 300, // æ•µäººè­¦æˆ’ç¯„åœ
            colors: {
                bg: '#1e293b', 
                floor1: '#f1f5f9',
                floor2: '#e2e8f0',
                wall: '#334155',
                water: '#3b82f6',
                enemy: '#16a34a',
                mine: '#ef4444',
                lightwave: '#fef08a'
            }
        };

        // --- è™›æ“¬æ–æ¡¿ç³»çµ± ---
        const Joystick = {
            active: false,
            origin: { x: 0, y: 0 },
            current: { x: 0, y: 0 },
            vector: { x: 0, y: 0 }, 
            touchId: null,
            radius: 60, 
            
            init() {
                const zone = document.getElementById('joystick-zone');
                const knob = document.getElementById('joystick-knob');
                
                zone.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.changedTouches[0];
                    this.touchId = touch.identifier;
                    this.active = true;
                    
                    const rect = zone.getBoundingClientRect();
                    this.origin = { 
                        x: rect.left + rect.width / 2, 
                        y: rect.top + rect.height / 2 
                    };
                    
                    this.updatePosition(touch.clientX, touch.clientY);
                    knob.classList.add('active');
                }, { passive: false });

                zone.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    for(let i=0; i<e.changedTouches.length; i++) {
                        if(e.changedTouches[i].identifier === this.touchId) {
                            this.updatePosition(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
                            break;
                        }
                    }
                }, { passive: false });

                const endHandler = (e) => {
                    for(let i=0; i<e.changedTouches.length; i++) {
                        if(e.changedTouches[i].identifier === this.touchId) {
                            this.reset();
                            break;
                        }
                    }
                };
                zone.addEventListener('touchend', endHandler);
                zone.addEventListener('touchcancel', endHandler);
            },

            updatePosition(clientX, clientY) {
                const knob = document.getElementById('joystick-knob');
                let dx = clientX - this.origin.x;
                let dy = clientY - this.origin.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                if (distance > this.radius) {
                    const angle = Math.atan2(dy, dx);
                    dx = Math.cos(angle) * this.radius;
                    dy = Math.sin(angle) * this.radius;
                }

                this.vector.x = dx / this.radius;
                this.vector.y = dy / this.radius;
                knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            },

            reset() {
                this.active = false;
                this.touchId = null;
                this.vector = { x: 0, y: 0 };
                const knob = document.getElementById('joystick-knob');
                knob.style.transform = `translate(-50%, -50%)`;
                knob.classList.remove('active');
            }
        };

        // --- é¡é ­ç³»çµ± ---
        const Camera = {
            x: 0, y: 0,
            follow(target) {
                this.x = target.x - canvas.width / 2;
                this.y = target.y - canvas.height / 2;
                
                const mapW = Game.mapCols * CONFIG.tileSize;
                const mapH = Game.mapRows * CONFIG.tileSize;
                
                this.x = Math.max(0, Math.min(this.x, mapW - canvas.width));
                this.y = Math.max(0, Math.min(this.y, mapH - canvas.height));
                
                if (mapW < canvas.width) this.x = -(canvas.width - mapW) / 2;
                if (mapH < canvas.height) this.y = -(canvas.height - mapH) / 2;
            }
        };

        // --- éŠæˆ²ä¸»é«” ---
        const canvas = document.getElementById('game-layer');
        const ctx = canvas.getContext('2d');

        const Game = {
            running: false,
            lastTime: 0,
            timeElapsed: 0,
            
            mapCols: 30, 
            mapRows: 30,
            grid: [],
            entities: [],
            particles: [],
            obstacles: [],
            
            mineCount: 0,
            enemiesKilled: 0,
            totalEnemies: 20,
            
            init() {
                this.resize();
                Joystick.init();
                
                const btnShoot = document.getElementById('btn-shoot');
                const btnMine = document.getElementById('btn-mine');
                
                let shootInterval;
                const startShoot = (e) => {
                    e.preventDefault();
                    if(!this.running) return;
                    this.player.shoot();
                    shootInterval = setInterval(() => this.player.shoot(), 200);
                    btnShoot.style.transform = 'scale(0.9)';
                };
                const stopShoot = (e) => {
                    e.preventDefault();
                    clearInterval(shootInterval);
                    btnShoot.style.transform = 'scale(1)';
                };

                btnShoot.addEventListener('touchstart', startShoot);
                btnShoot.addEventListener('touchend', stopShoot);
                btnShoot.addEventListener('mousedown', startShoot);
                btnShoot.addEventListener('mouseup', stopShoot);

                const placeMine = (e) => {
                    e.preventDefault();
                    if(!this.running) return;
                    this.player.placeMine();
                    btnMine.style.transform = 'scale(0.9)';
                    setTimeout(() => btnMine.style.transform = 'scale(1)', 100);
                };
                btnMine.addEventListener('touchstart', placeMine);
                btnMine.addEventListener('mousedown', placeMine);

                window.addEventListener('resize', () => this.resize());
            },

            resize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                ctx.imageSmoothingEnabled = false; 
            },

            start() {
                document.getElementById('start-modal').classList.remove('show');
                document.getElementById('end-modal').classList.remove('show');
                
                this.running = true;
                this.mineCount = 0;
                this.timeElapsed = 0;
                this.enemiesKilled = 0;
                this.particles = [];
                this.obstacles = [];
                this.entities = [];
                
                this.generateLevel();
                
                this.player = new Player(CONFIG.tileSize * 2, CONFIG.tileSize * 2);
                this.entities.push(this.player);

                for(let i=0; i<8; i++) this.spawnEnemy();

                this.lastTime = performance.now();
                requestAnimationFrame((t) => this.loop(t));
                this.updateUI();
            },

            restart() {
                this.start();
            },

            generateLevel() {
                this.grid = [];
                // ç”¢ç”Ÿæ›´å¤šæ°´ç®¡ä»¥ä¾›æ¸…æ´—
                for(let r=0; r<this.mapRows; r++) {
                    let row = [];
                    for(let c=0; c<this.mapCols; c++) {
                        if(r===0 || r===this.mapRows-1 || c===0 || c===this.mapCols-1) {
                            row.push(1);
                            this.obstacles.push(new Wall(c*CONFIG.tileSize, r*CONFIG.tileSize));
                        } else {
                            // å¢åŠ æ°´ç®¡ç”Ÿæˆç‡
                            if (Math.random() < 0.15 && (r > 4 || c > 4)) {
                                row.push(1); 
                                this.obstacles.push(new Pipe(c*CONFIG.tileSize, r*CONFIG.tileSize));
                            } else {
                                row.push(0); 
                            }
                        }
                    }
                    this.grid.push(row);
                }
            },

            spawnEnemy() {
                let x, y, c, r;
                let attempts = 0;
                do {
                    c = Math.floor(Math.random() * (this.mapCols - 2)) + 1;
                    r = Math.floor(Math.random() * (this.mapRows - 2)) + 1;
                    x = c * CONFIG.tileSize;
                    y = r * CONFIG.tileSize;
                    attempts++;
                    let dist = Math.hypot(x - this.player.x, y - this.player.y);
                    if (this.grid[r][c] === 0 && dist > 500) break;
                } while (attempts < 50);

                if (attempts < 50) {
                    this.entities.push(new Enemy(x + 10, y + 10));
                }
            },

            loop(now) {
                if (!this.running) return;
                const dt = (now - this.lastTime) / 1000;
                this.lastTime = now;

                this.update(dt);
                this.draw();

                requestAnimationFrame((t) => this.loop(t));
            },

            update(dt) {
                if (Math.floor(Date.now()/1000) > this.timeElapsed + Math.floor(this.lastTime/1000)) {
                   // ç°¡å–®è¨ˆæ™‚ä¿®æ­£
                }
                this.timeElapsed += dt;
                
                // ç”Ÿæ€ªé‚è¼¯
                if (Math.floor(this.timeElapsed) % 3 === 0 && this.entities.filter(e => e.type === 'enemy').length < 15) {
                    if (Math.random() < 0.05) this.spawnEnemy();
                }

                let mins = Math.floor(this.timeElapsed/60).toString().padStart(2,'0');
                let secs = Math.floor(this.timeElapsed%60).toString().padStart(2,'0');
                document.getElementById('time-val').innerText = `${mins}:${secs}`;

                Camera.follow(this.player);

                this.entities.forEach(e => e.update(dt));
                this.obstacles.forEach(o => o.update(dt));
                
                this.particles.forEach(p => p.update(dt));
                this.particles = this.particles.filter(p => p.life > 0);

                this.entities = this.entities.filter(e => !e.dead);
                this.obstacles = this.obstacles.filter(o => !o.dead);

                if (this.player.hp <= 0) this.gameOver(false);
                
                // å‹åˆ©æ¢ä»¶ï¼šæ‰€æœ‰æ°´ç®¡æ´—ä¹¾æ·¨
                const dirtyPipes = this.obstacles.filter(o => o instanceof Pipe && o.dirty).length;
                const enemies = this.entities.filter(e => e.type === 'enemy').length;
                document.getElementById('obj-text').innerText = `å‰©é¤˜æ°´ç®¡: ${dirtyPipes} | ç´°èŒ: ${enemies}`;
                
                if (dirtyPipes === 0 && enemies === 0) this.gameOver(true);
            },

            draw() {
                ctx.fillStyle = CONFIG.colors.bg;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.save();
                ctx.translate(-Camera.x, -Camera.y);

                const startCol = Math.floor(Camera.x / CONFIG.tileSize);
                const endCol = startCol + (canvas.width / CONFIG.tileSize) + 1;
                const startRow = Math.floor(Camera.y / CONFIG.tileSize);
                const endRow = startRow + (canvas.height / CONFIG.tileSize) + 1;

                for (let r = startRow; r <= endRow; r++) {
                    for (let c = startCol; c <= endCol; c++) {
                        if (r >= 0 && r < this.mapRows && c >= 0 && c < this.mapCols) {
                            if (this.grid[r][c] === 0) {
                                ctx.fillStyle = (r+c)%2===0 ? CONFIG.colors.floor1 : CONFIG.colors.floor2;
                                ctx.fillRect(c*CONFIG.tileSize, r*CONFIG.tileSize, CONFIG.tileSize, CONFIG.tileSize);
                            }
                        }
                    }
                }

                // å…‰æ³¢åœ¨æœ€ä¸‹å±¤(åœ°æ¿ä¸Š)ï¼Œç‰©é«”åœ¨ä¸Šé¢
                const lightWaves = this.entities.filter(e => e instanceof LightWave);
                lightWaves.forEach(w => w.draw(ctx));

                const renderList = [...this.obstacles, ...this.entities.filter(e => !(e instanceof LightWave)), ...this.particles];
                renderList.sort((a, b) => (a.y + a.h) - (b.y + b.h));

                renderList.forEach(obj => obj.draw(ctx));

                ctx.restore();
            },

            shakeScreen() {
                const intensity = 10;
                canvas.style.transform = `translate(${Math.random()*intensity - intensity/2}px, ${Math.random()*intensity - intensity/2}px)`;
                setTimeout(() => canvas.style.transform = 'none', 50);
            },

            addFloatingText(x, y, text, color) {
                const el = document.createElement('div');
                el.className = 'floating-text';
                el.style.left = (x - Camera.x) + 'px'; 
                el.style.top = (y - Camera.y) + 'px';
                el.style.color = color;
                el.innerText = text;
                document.getElementById('game-layer').parentNode.appendChild(el); 
                setTimeout(() => el.remove(), 1000);
            },

            updateUI() {
                document.getElementById('hp-val').innerText = this.player.hp;
                document.getElementById('mine-val').innerText = this.mineCount;
                document.getElementById('mine-count').innerText = this.mineCount;
                
                const btnMine = document.getElementById('btn-mine');
                if (this.mineCount > 0) {
                     btnMine.style.borderColor = '#fbbf24';
                     btnMine.style.background = 'linear-gradient(135deg, #ef4444, #b91c1c)';
                } else {
                     btnMine.style.borderColor = 'rgba(255,255,255,0.4)';
                     btnMine.style.background = 'rgba(255, 255, 255, 0.1)';
                }
            },

            gameOver(win) {
                this.running = false;
                const modal = document.getElementById('end-modal');
                const title = document.getElementById('end-title');
                const msg = document.getElementById('end-msg');
                const icon = document.getElementById('end-icon');

                modal.classList.add('show');
                if (win) {
                    icon.innerText = "âœ¨";
                    title.innerText = "å®Œç¾æ·¨åŒ–ï¼";
                    title.className = "text-3xl font-black text-green-600 mb-2";
                    msg.innerText = `æ‰€æœ‰æ°´ç®¡éƒ½ä¹¾æ·¨äº†ï¼`;
                } else {
                    icon.innerText = "ğŸ¦ ";
                    title.innerText = "ä»»å‹™å¤±æ•—";
                    title.className = "text-3xl font-black text-red-600 mb-2";
                    msg.innerText = `ç´°èŒå¤ªå¤šäº†...`;
                }
            }
        };

        // --- é¡åˆ¥å®šç¾© ---

        class Entity {
            constructor(x, y, w, h) {
                this.x = x; this.y = y; this.w = w; this.h = h;
                this.vx = 0; this.vy = 0;
                this.dead = false;
                this.type = 'entity';
            }
            update(dt) {
                this.x += this.vx;
                this.y += this.vy;
            }
            draw(ctx) {}
            get center() { return { x: this.x + this.w/2, y: this.y + this.h/2 }; }
            
            checkCollision(other) {
                return (this.x < other.x + other.w &&
                        this.x + this.w > other.x &&
                        this.y < other.y + other.h &&
                        this.y + this.h > other.y);
            }
        }

        class Player extends Entity {
            constructor(x, y) {
                super(x, y, 40, 40);
                this.hp = 5;
                this.speed = CONFIG.playerSpeed;
                this.lastShot = 0;
                this.facing = {x: 0, y: 1};
                this.invincible = 0;
            }

            update(dt) {
                if (Joystick.active) {
                    this.vx = Joystick.vector.x * this.speed * dt;
                    this.vy = Joystick.vector.y * this.speed * dt;
                    if (Math.abs(Joystick.vector.x) > 0.1 || Math.abs(Joystick.vector.y) > 0.1) {
                         this.facing = { ...Joystick.vector };
                    }
                } else {
                    this.vx = 0; this.vy = 0;
                }

                if (!this.isValidMove(this.x + this.vx, this.y)) this.vx = 0;
                if (!this.isValidMove(this.x, this.y + this.vy)) this.vy = 0;

                super.update(dt);
                
                this.x = Math.max(0, Math.min(this.x, Game.mapCols*CONFIG.tileSize - this.w));
                this.y = Math.max(0, Math.min(this.y, Game.mapRows*CONFIG.tileSize - this.h));

                if (this.invincible > 0) this.invincible -= dt;
            }

            isValidMove(nx, ny) {
                const padding = 5;
                const points = [
                    {c: Math.floor((nx+padding)/CONFIG.tileSize), r: Math.floor((ny+padding)/CONFIG.tileSize)},
                    {c: Math.floor((nx+this.w-padding)/CONFIG.tileSize), r: Math.floor((ny+padding)/CONFIG.tileSize)},
                    {c: Math.floor((nx+padding)/CONFIG.tileSize), r: Math.floor((ny+this.h-padding)/CONFIG.tileSize)},
                    {c: Math.floor((nx+this.w-padding)/CONFIG.tileSize), r: Math.floor((ny+this.h-padding)/CONFIG.tileSize)}
                ];
                return points.every(p => Game.grid[p.r] && Game.grid[p.r][p.c] === 0);
            }

            shoot() {
                const now = Date.now();
                if (now - this.lastShot > 250) {
                    this.lastShot = now;
                    let mag = Math.sqrt(this.facing.x**2 + this.facing.y**2);
                    if (mag === 0) mag = 1; 
                    
                    Game.entities.push(new Bullet(
                        this.center.x, this.center.y, 
                        (this.facing.x/mag), (this.facing.y/mag)
                    ));
                }
            }

            placeMine() {
                if (Game.mineCount > 0) {
                    Game.mineCount--;
                    Game.entities.push(new Mine(this.center.x, this.center.y));
                    Game.updateUI();
                    Game.addFloatingText(this.x, this.y, "åœ°é›·è¨­ç½®!", "#fbbf24");
                } else {
                    Game.addFloatingText(this.x, this.y, "éœ€è¦æ´—æ°´ç®¡!", "#ef4444");
                }
            }
            
            takeDamage(amt) {
                if (this.invincible > 0) return;
                this.hp -= amt;
                this.invincible = 1.0;
                Game.shakeScreen();
                Game.updateUI();
                Game.addFloatingText(this.x, this.y, "-1 HP", "#ef4444");
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.center.x, this.center.y);
                if (this.invincible > 0 && Math.floor(Date.now()/100)%2) ctx.globalAlpha = 0.5;
                if (this.facing.x < 0) ctx.scale(-1, 1);

                // ç‰›ä»”è¤²
                ctx.fillStyle = '#1e40af'; 
                ctx.fillRect(-8, 10, 6, 12); 
                ctx.fillRect(2, 10, 6, 12); 

                // ç¶ ä¸Šè¡£
                ctx.fillStyle = '#16a34a'; 
                ctx.fillRect(-10, -5, 20, 18); 
                ctx.fillRect(-14, -5, 4, 8);
                ctx.fillRect(10, -5, 4, 8);

                // é•·æ–¹è‡‰
                ctx.fillStyle = '#fde68a'; 
                ctx.fillRect(-9, -22, 18, 18); 

                // é»‘æ¡†çœ¼é¡
                ctx.fillStyle = 'black';
                ctx.fillRect(-8, -16, 6, 4); 
                ctx.fillRect(2, -16, 6, 4); 
                ctx.fillRect(-2, -15, 4, 1); 
                
                ctx.fillStyle = '#bfdbfe'; 
                ctx.fillRect(-7, -15, 4, 2);
                ctx.fillRect(3, -15, 4, 2);

                // é ­é«®
                ctx.fillStyle = '#0f172a';
                ctx.fillRect(-10, -25, 20, 6); 
                ctx.fillRect(-10, -25, 4, 15); 

                ctx.restore();
            }
        }

        class Enemy extends Entity {
            constructor(x, y) {
                super(x, y, 40, 40);
                this.maxSpeed = CONFIG.enemySpeed;
                this.wanderSpeed = CONFIG.enemyWanderSpeed;
                this.hp = 3;
                this.type = 'enemy';
                this.wanderTimer = 0;
                this.wanderDir = {x: 0, y: 0};
                this.state = 'wander'; // 'wander' or 'chase'
            }
            
            update(dt) {
                const p = Game.player;
                const dx = p.x - this.x;
                const dy = p.y - this.y;
                const dist = Math.hypot(dx, dy);
                
                // ç‹€æ…‹åˆ‡æ›é‚è¼¯
                if (dist < CONFIG.enemyAggroRange) {
                    this.state = 'chase';
                } else {
                    this.state = 'wander';
                }

                if (this.state === 'chase') {
                    // è¿½æ“Šæ¨¡å¼ï¼šå¿«é€Ÿç§»å‹•
                    if (dist > 0) {
                        this.vx = (dx / dist) * this.maxSpeed * dt;
                        this.vy = (dy / dist) * this.maxSpeed * dt;
                    }
                } else {
                    // éŠè•©æ¨¡å¼ï¼šå…¨åœ°åœ–ç·©æ…¢ç§»å‹•
                    this.wanderTimer -= dt;
                    if (this.wanderTimer <= 0) {
                        // 2-4ç§’æ›ä¸€æ¬¡æ–¹å‘
                        this.wanderTimer = 2 + Math.random() * 2; 
                        const angle = Math.random() * Math.PI * 2;
                        // è¨­å®šéŠè•©å‘é‡
                        this.wanderDir = {
                            x: Math.cos(angle) * this.wanderSpeed * dt,
                            y: Math.sin(angle) * this.wanderSpeed * dt
                        };
                    }
                    this.vx = this.wanderDir.x;
                    this.vy = this.wanderDir.y;
                }

                // ç°¡å–®ç¢°æ’æ¨æ“  (é¿å…é‡ç–Š)
                Game.entities.forEach(e => {
                    if (e !== this && e.type === 'enemy' && this.checkCollision(e)) {
                        this.vx -= (e.x - this.x) * 2 * dt;
                        this.vy -= (e.y - this.y) * 2 * dt;
                    }
                });

                // ç¢°æ’æª¢æ¸¬èˆ‡ç§»å‹•
                const nextX = this.x + this.vx;
                const nextY = this.y + this.vy;
                
                if(this.isValidPos(nextX, this.y)) {
                    this.x = nextX;
                } else if (this.state === 'wander') {
                    // éŠè•©æ’ç‰†å°±æ›æ–¹å‘
                    this.wanderTimer = 0; 
                }

                if(this.isValidPos(this.x, nextY)) {
                    this.y = nextY;
                } else if (this.state === 'wander') {
                    this.wanderTimer = 0;
                }

                // æ”»æ“Šç©å®¶
                if (this.checkCollision(p)) {
                    p.takeDamage(1);
                }
            }
            
            isValidPos(nx, ny) {
                 // æª¢æŸ¥ä¸­å¿ƒé»æ˜¯å¦åœ¨åœ°æ¿ä¸Š
                 const c = Math.floor((nx + this.w/2) / CONFIG.tileSize);
                 const r = Math.floor((ny + this.h/2) / CONFIG.tileSize);
                 // ç¢ºä¿ä¸è¶…å‡ºåœ°åœ–é‚Šç•Œ
                 if (c < 0 || c >= Game.mapCols || r < 0 || r >= Game.mapRows) return false;
                 return Game.grid[r] && Game.grid[r][c] === 0;
            }

            takeDamage(amt) {
                this.hp -= amt;
                if (this.hp <= 0) {
                    this.dead = true;
                    Game.enemiesKilled++;
                    for(let i=0; i<5; i++) {
                         Game.particles.push(new Particle(this.center.x, this.center.y, 'goo'));
                    }
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.center.x, this.center.y);
                const scale = 1 + Math.sin(Date.now() / 200) * 0.1;
                ctx.scale(scale, 1/scale);
                
                ctx.fillStyle = CONFIG.colors.enemy;
                ctx.beginPath();
                ctx.arc(0, 0, 15, Math.PI, 0); 
                ctx.lineTo(15, 10); 
                ctx.lineTo(0, 15);
                ctx.lineTo(-15, 10);
                ctx.fill();
                
                // è¡¨æƒ…éš¨ç‹€æ…‹æ”¹è®Š
                if (this.state === 'chase') {
                    // æ†¤æ€’è¿½æ“Š
                    ctx.fillStyle = '#064e3b';
                    ctx.beginPath(); ctx.moveTo(-8, -5); ctx.lineTo(-2, 0); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(8, -5); ctx.lineTo(2, 0); ctx.stroke();
                } else {
                    // ç™¼å‘†éŠè•© (åœ“çœ¼ç›)
                    ctx.fillStyle = 'white';
                    ctx.beginPath(); ctx.arc(-5, -5, 3, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(5, -5, 3, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = 'black';
                    ctx.beginPath(); ctx.arc(-5, -5, 1, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(5, -5, 1, 0, Math.PI*2); ctx.fill();
                }
                
                ctx.restore();
                
                ctx.fillStyle = 'red';
                ctx.fillRect(this.x, this.y - 10, this.w, 4);
                ctx.fillStyle = '#22c55e';
                ctx.fillRect(this.x, this.y - 10, this.w * (this.hp/3), 4);
            }
        }

        // --- æ–°å¢ï¼šåå­—å…‰æ³¢ ---
        class LightWave extends Entity {
            constructor(cx, cy) {
                super(0, 0, 0, 0); // è™›æ“¬å¤§å°
                this.cx = cx; this.cy = cy;
                this.lifespan = 0.5; // æŒçºŒ 0.5 ç§’
                this.thickness = 40;
                
                // æ©«å‘èˆ‡ç¸±å‘çš„çŸ©å½¢
                this.hRect = { x: 0, y: cy - this.thickness/2, w: Game.mapCols * CONFIG.tileSize, h: this.thickness };
                this.vRect = { x: cx - this.thickness/2, y: 0, w: this.thickness, h: Game.mapRows * CONFIG.tileSize };
            }

            update(dt) {
                this.lifespan -= dt;
                if (this.lifespan <= 0) this.dead = true;

                // å‚·å®³åˆ¤å®š
                Game.entities.forEach(e => {
                    if (e.type === 'enemy') {
                        if (this.checkHit(e, this.hRect) || this.checkHit(e, this.vRect)) {
                            e.takeDamage(10); // ç§’æ®º
                            Game.particles.push(new Particle(e.center.x, e.center.y, 'explosion'));
                        }
                    }
                });
            }

            checkHit(entity, rect) {
                return (entity.x < rect.x + rect.w &&
                        entity.x + entity.w > rect.x &&
                        entity.y < rect.y + rect.h &&
                        entity.y + entity.h > rect.y);
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.lifespan * 2; // æ·¡å‡º
                ctx.fillStyle = CONFIG.colors.lightwave;
                
                // ç¹ªè£½å…‰æŸ
                ctx.fillRect(this.hRect.x, this.hRect.y, this.hRect.w, this.hRect.h);
                ctx.fillRect(this.vRect.x, this.vRect.y, this.vRect.w, this.vRect.h);
                
                // æ ¸å¿ƒäº®é»
                ctx.fillStyle = '#fff';
                ctx.globalAlpha = this.lifespan;
                ctx.fillRect(this.hRect.x, this.hRect.y + 10, this.hRect.w, this.hRect.h - 20);
                ctx.fillRect(this.vRect.x + 10, this.vRect.y, this.vRect.w - 20, this.vRect.h);
                
                ctx.restore();
            }
        }

        class Bullet extends Entity {
            constructor(x, y, dx, dy) {
                super(x, y, 10, 10);
                this.vx = dx * 500;
                this.vy = dy * 500;
                this.life = 1.0;
            }
            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.life -= dt;
                if (this.life <= 0) this.dead = true;

                // æ’ç‰†/æ°´ç®¡
                let c = Math.floor(this.center.x / CONFIG.tileSize);
                let r = Math.floor(this.center.y / CONFIG.tileSize);
                
                // æª¢æŸ¥æ˜¯å¦æ‰“ä¸­éšœç¤™ç‰©
                let hitPipe = Game.obstacles.find(o => o.x / CONFIG.tileSize === c && o.y / CONFIG.tileSize === r);
                if (hitPipe) {
                    this.dead = true;
                    if (hitPipe instanceof Pipe) {
                        hitPipe.clean(); // æ¸…æ´—æ°´ç®¡
                    } else {
                        // æ™®é€šç‰†å£
                        Game.particles.push(new Particle(this.x, this.y, 'water'));
                    }
                }

                Game.entities.forEach(e => {
                    if (e.type === 'enemy' && this.checkCollision(e)) {
                        e.takeDamage(1);
                        this.dead = true;
                        Game.particles.push(new Particle(this.x, this.y, 'water'));
                    }
                });
            }
            draw(ctx) {
                ctx.fillStyle = '#60a5fa';
                ctx.beginPath(); ctx.arc(this.x, this.y, 6, 0, Math.PI*2); ctx.fill();
            }
        }

        class Mine extends Entity {
            constructor(x, y) {
                super(x - 15, y - 15, 30, 30);
                this.timer = 2.0;
            }
            update(dt) {
                this.timer -= dt;
                if (this.timer <= 0) {
                    this.dead = true;
                    this.explode();
                }
            }
            explode() {
                Game.shakeScreen();
                Game.mineCount--;
                Game.updateUI();
                // ç¯„åœå‚·å®³
                const radius = 100;
                Game.entities.forEach(e => {
                    if (e.type === 'enemy') {
                        const dist = Math.hypot(e.center.x - this.center.x, e.center.y - this.center.y);
                        if (dist < radius) e.takeDamage(5); // ç§’æ®º
                    }
                });
                // ç ´å£æ°´ç®¡
                Game.obstacles.forEach(o => {
                    if (o instanceof Pipe) {
                        const dist = Math.hypot(o.x - this.center.x, o.y - this.center.y);
                        if (dist < radius) o.clean();
                    }
                });
                // ç‰¹æ•ˆ
                for(let i=0; i<10; i++) Game.particles.push(new Particle(this.center.x, this.center.y, 'explosion'));
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.center.x, this.center.y);
                const pulse = Math.sin(Date.now()/50) * 0.2 + 1;
                ctx.scale(pulse, pulse);
                ctx.fillStyle = '#ef4444';
                ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'black';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(Math.ceil(this.timer), 0, 4);
                ctx.restore();
            }
        }

        class Wall {
            constructor(x, y) {
                this.x = x; this.y = y; this.w = CONFIG.tileSize; this.h = CONFIG.tileSize;
                this.dead = false;
            }
            update(dt) {}
            draw(ctx) {
                ctx.fillStyle = CONFIG.colors.wall;
                ctx.fillRect(this.x, this.y, this.w, this.h);
                ctx.fillStyle = '#475569'; // Highlight
                ctx.fillRect(this.x, this.y, this.w, 5);
            }
        }

        class Pipe extends Wall {
            constructor(x, y) {
                super(x, y);
                this.dirty = true;
                this.rotation = Math.floor(Math.random() * 4); 
            }
            clean() {
                if (this.dirty) {
                    this.dirty = false;
                    this.dead = true; 
                    
                    // æ¸…é™¤åœ°åœ–æ ¼æ“‹ï¼Œè®Šæˆåœ°æ¿
                    let c = this.x / CONFIG.tileSize;
                    let r = this.y / CONFIG.tileSize;
                    Game.grid[r][c] = 0;

                    // çµ¦äºˆåœ°é›·çå‹µ
                    Game.mineCount++;
                    Game.updateUI();
                    Game.addFloatingText(this.x, this.y, "+1 åœ°é›· ğŸ’£", "#fbbf24");

                    // è§¸ç™¼å…‰æ³¢
                    Game.entities.push(new LightWave(this.x + this.w/2, this.y + this.h/2));
                    
                    // ç‰¹æ•ˆ
                    for(let i=0; i<5; i++) Game.particles.push(new Particle(this.x + this.w/2, this.y + this.h/2, 'water'));
                }
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x + this.w/2, this.y + this.h/2);
                ctx.rotate(this.rotation * Math.PI / 2);
                
                // é«’æ±¡ç‹€æ…‹ï¼šæ•´æ¢æ°´ç®¡è¢«æ·±è‰²æ·¤æ³¥å µå¡
                if (this.dirty) {
                    // åº•è‰²ï¼šæ·±è¤ç¶ è‰²æ·¤æ³¥
                    ctx.fillStyle = '#3f6212';
                    ctx.fillRect(-this.w/2, -this.h/4, this.w, this.h/2); // ä¸»ç®¡èº«
                    
                    // ç´‹ç†ï¼šæ›´æ·±çš„æ–‘é»ï¼Œæ¨¡æ“¬å µå¡æ„Ÿ
                    ctx.fillStyle = '#1a2e05';
                    ctx.fillRect(-this.w/2 + 5, -this.h/4 + 5, 20, this.h/2 - 10);
                    ctx.fillRect(5, -this.h/4 + 5, 20, this.h/2 - 10);
                    
                    // å´é‚Šçªå‡ºçš„å µå¡ç‰©
                    ctx.fillStyle = '#4d7c0f';
                    ctx.beginPath();
                    ctx.arc(0, 0, 15, 0, Math.PI*2); // ä¸­é–“ä¸€å¨
                    ctx.fill();

                    // ç®¡å£é‚Šç·£ (ä¾ç„¶é¡¯ç¤ºä¸€é»é‡‘å±¬é‚Šæ¡†ï¼Œè®“äººçŸ¥é“æ˜¯ç®¡å­)
                    ctx.strokeStyle = '#57534e';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-this.w/2, -this.h/4, this.w, this.h/2);

                } else {
                    // é›–ç„¶é‚è¼¯ä¸Š clean å¾Œæœƒæ­»æ‰ï¼Œä½†ä¿ç•™ç¹ªè£½é‚è¼¯
                    // é‡‘å±¬æ¼¸å±¤
                    const grad = ctx.createLinearGradient(0, -this.h/2, 0, this.h/2);
                    grad.addColorStop(0, '#94a3b8');
                    grad.addColorStop(0.5, '#e2e8f0');
                    grad.addColorStop(1, '#64748b');
                    ctx.fillStyle = grad;
                    ctx.fillRect(-this.w/2, -this.h/4, this.w, this.h/2);
                }
                
                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, type) {
                this.x = x; this.y = y;
                this.type = type;
                this.life = 1.0;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 100;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                
                if (type === 'coin') {
                    this.vy = -50; this.vx = 0;
                }
            }
            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.life -= dt;
            }
            draw(ctx) {
                ctx.globalAlpha = this.life;
                if (this.type === 'water') {
                    ctx.fillStyle = '#bae6fd';
                    ctx.beginPath(); ctx.arc(this.x, this.y, 4, 0, Math.PI*2); ctx.fill();
                } else if (this.type === 'goo') {
                    ctx.fillStyle = '#a3e635';
                    ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI*2); ctx.fill();
                } else if (this.type === 'explosion') {
                    ctx.fillStyle = '#fca5a5';
                    ctx.beginPath(); ctx.arc(this.x, this.y, 10 * this.life, 0, Math.PI*2); ctx.fill();
                } else if (this.type === 'coin') {
                    ctx.font = '20px Arial';
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillText('ğŸ’°', this.x, this.y);
                }
                ctx.globalAlpha = 1.0;
            }
        }

        // --- å•Ÿå‹• ---
        window.onload = () => {
            Game.init();
        };

    </script>
</body>
</html>
